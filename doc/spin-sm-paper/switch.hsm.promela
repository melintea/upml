/*

 About 10k states in the first draft => 3300 now

TODO:
- queue state transitions at the front in reverse order

*/

#define idx_unknown -1

#define idx_state_BothOff 0
#define idx_state_LampOff 1
#define idx_state_LightOn 2
#define idx_state_WallOff 3

mtype = { event_ExitState, event_EnterState, event_LampSwitch, event_WallSwitch, event_Dummy, }

typedef event {mtype evId; short toState};

chan  _stateMachineChannel = [3] of {event};
short _currentState = idx_unknown;
bool  _stateMachineReady = false;
bool  _isLightOn = false;


inline push_event(evt, toState) // sorted order
{
    _stateMachineChannel!!evt(toState);
}
    
inline send_event_if_empty(evt, toState)
{
    empty(_stateMachineChannel);
    _stateMachineChannel!evt(toState);
}
    

proctype StateBothOff(chan superChannel)
{
    local event evtRecv; 

entry_BothOff:
    /* execute on entry BothOff actions */
    _currentState = idx_state_BothOff; //0
    _stateMachineReady = true;

body_BothOff:
end_BothOff: // valid verification' end
    superChannel?evtRecv; 
    printf("MSC: > StateBothOff event %e in state %d\n", evtRecv.evId, _currentState); 
    if
        :: (evtRecv.evId == event_ExitState) -> 
        assert(evtRecv.toState == idx_state_BothOff);
        goto exit_BothOff;
        
        :: (evtRecv.evId == event_LampSwitch) -> 
        /* execute transition actions then on exit state BothOff; not UML-compliant*/
        atomic { push_event(event_EnterState, idx_state_WallOff); }
        goto exit_BothOff;

        :: (evtRecv.evId == event_WallSwitch) -> 
        atomic { push_event(event_EnterState, idx_state_LampOff); }
        goto exit_BothOff;
        
        // No warning?
        :: (evtRecv.evId == event_Dummy) -> 
        goto body_BothOff;
        
        //:: else
        //  send event to substates/regions for processing
    fi
exit_BothOff:
    /* execute on exit BothOff actions */
}


proctype StateLampOff(chan superChannel)
{
    local event evtRecv; 

entry_LampOff:
    _currentState = idx_state_LampOff; //1

body_LampOff:
    superChannel?evtRecv; 
    printf("MSC: > StateLampOff event %e in state %d\n", evtRecv.evId, _currentState); 
    if
        :: (evtRecv.evId == event_ExitState) -> 
        assert(evtRecv.toState == idx_state_LampOff);
        goto exit_LampOff;
        
        :: (evtRecv.evId == event_LampSwitch) -> 
        atomic { push_event(event_EnterState, idx_state_LightOn); }
        goto exit_LampOff;

        :: (evtRecv.evId == event_WallSwitch) -> 
        atomic { push_event(event_EnterState, idx_state_BothOff); }
        goto exit_LampOff;
    fi

exit_LampOff:
}

proctype StateLightOn(chan superChannel)
{
    local event evtRecv; 

entry_LightOn: 
    _currentState = idx_state_LightOn; //2
    _isLightOn = true;

body_LightOn:
    superChannel?evtRecv; 
    printf("MSC: > StateLightOn event %e in state %d\n", evtRecv.evId, _currentState); 
    if
        :: (evtRecv.evId == event_ExitState) -> 
        assert(evtRecv.toState == idx_state_LightOn);
        goto exit_LightOn;
        
        :: (evtRecv.evId == event_LampSwitch) -> 
        atomic { push_event(event_EnterState, idx_state_LampOff); }
        goto exit_LightOn;

        :: (evtRecv.evId == event_WallSwitch) -> 
        atomic { push_event(event_EnterState, idx_state_WallOff); }
        goto exit_LightOn;
    fi

exit_LightOn:
    _isLightOn = false;
}

proctype StateWallOff(chan superChannel)
{
    local event evtRecv; 

entry_WallOff:
    _currentState = idx_state_WallOff; //3

body_WallOff:
    superChannel?evtRecv; 
    printf("MSC: > StateWallOff event %e in state %d\n", evtRecv.evId, _currentState); 
    if
        :: (evtRecv.evId == event_ExitState) -> 
        assert(evtRecv.toState == idx_state_WallOff);
        goto exit_WallOff;
        
        :: (evtRecv.evId == event_LampSwitch) -> 
        atomic { push_event(event_EnterState, idx_state_BothOff); }
        goto exit_WallOff;

        :: (evtRecv.evId == event_WallSwitch) -> 
        atomic { push_event(event_EnterState, idx_state_LightOn); }
        goto exit_WallOff;
    fi

exit_WallOff:
}

proctype Switch(chan superChannel)
{
    local event evtRecv; 
    chan substateChannel = [1] of {event};

entry_Switch:
    push_event(event_EnterState, idx_state_BothOff); // initial state

body_Switch:
end_Switch: 
    superChannel?evtRecv; 
    printf("MSC: > Switch event %e in state %d\n", evtRecv.evId, _currentState); 
    if
        :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_BothOff) -> 
        run StateBothOff(substateChannel);
        goto body_Switch;

        :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_LampOff) -> 
        run StateLampOff(substateChannel);
        goto body_Switch;

        :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_LightOn) -> 
        run StateLightOn(substateChannel);
        goto body_Switch;

        :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_WallOff) -> 
        run StateWallOff(substateChannel);
        goto body_Switch;

        :: else
        //send event to substates/regions for processing
        substateChannel!evtRecv.evId(_currentState);
        goto body_Switch;
    fi
    goto body_Switch;
} // Switch


proctype TestEnvironment() provided (_stateMachineReady)
{
    assert(_currentState == idx_state_BothOff);
    
    if
    :: true -> 
       send_event_if_empty(event_WallSwitch, _currentState); 
       send_event_if_empty(event_LampSwitch, _currentState); //assert(_isLightOn == true); // error because race condition
    :: true -> 
       send_event_if_empty(event_LampSwitch, _currentState); 
       send_event_if_empty(event_WallSwitch, _currentState); //assert(_isLightOn == true); // idem
    fi
    (_isLightOn == true);
    assert(_currentState == idx_state_LightOn);
    
    if
    :: true -> 
       send_event_if_empty(event_LampSwitch, _currentState);
       send_event_if_empty(event_WallSwitch, _currentState);
    :: true -> 
       send_event_if_empty(event_WallSwitch, _currentState);
       send_event_if_empty(event_LampSwitch, _currentState);
    fi
    (_isLightOn == false);
    (_currentState == idx_state_BothOff);
} // TestEnvironment


init {
    atomic {
        run Switch(_stateMachineChannel); 
        run TestEnvironment(); 
    }
    //(_nr_pr == 1); 
}


ltl { always/*[]*/ eventually/*<>*/
    (   (_currentState == idx_state_BothOff && _isLightOn == false) 
           implies/*->*/ (_currentState == idx_state_LightOn && _isLightOn == true) 
           implies/*->*/ (_currentState == idx_state_BothOff && _isLightOn == false)
)}

