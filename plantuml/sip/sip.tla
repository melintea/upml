/*
./upml --in ../plantuml/sip/sip.plantuml --backend tla --out ../plantuml/sip/sip.tla 
*/
/*
   Generated by UPML v0.06
   Wed Dec 18 10:06:07 2024


    (F:'';L:1;C:1)
    machine sip {
        (F:'';L:3;C:1)
        -- r3 {
            (F:'';L:21;C:1)
            state Alice final:0;initial:0 {
                (F:'';L:22;C:3)
                -- r22 {
                    (F:'';L:0;C:0)
                    state AEstablished final:0;initial:0 {
                        (F:'';L:30;C:3) AEstablished --> Aterminated Hangup[]/ (t30)
                        (F:'';L:29;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a29)
                    }
                    (F:'';L:0;C:0)
                    state AIdle final:0;initial:1 {
                        (F:'';L:23;C:3) AIdle --> AInitiated Dial[]/ (t23)
                    }
                    (F:'';L:0;C:0)
                    state AInitiated final:0;initial:0 {
                        (F:'';L:26;C:3) AInitiated --> AInitiated 1xx[]/ (t26)
                        (F:'';L:27;C:3) AInitiated --> AEstablished 2xx[]/ (t27)
                        (F:'';L:25;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a25)
                        (F:'';L:36;C:3) AInitiated:precondition: (,state:Alice:currentState,!=,state:BIdle,), (a36)
                        (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)
                        (F:'';L:38;C:3) AInitiated:invariant: (,state:Alice:currentState,!=,state:Bterminated,), (a38)
                    }
                    (F:'';L:0;C:0)
                    state Aterminated final:1;initial:0 {
                        (F:'';L:32;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a32)
                    }
                }
            }
            (F:'';L:43;C:1)
            state Bob final:0;initial:0 {
                (F:'';L:44;C:3)
                -- r44 {
                    (F:'';L:0;C:0)
                    state BEstablished final:0;initial:0 {
                        (F:'';L:51;C:3) BEstablished --> BEstablished ACK[]/ (t51)
                        (F:'';L:52;C:3) BEstablished --> Bterminated BYE[]/ (t52)
                        (F:'';L:50;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a50)
                    }
                    (F:'';L:0;C:0)
                    state BIdle final:0;initial:1 {
                        (F:'';L:45;C:3) BIdle --> BInitiated INVITE[]/ (t45)
                    }
                    (F:'';L:0;C:0)
                    state BInitiated final:0;initial:0 {
                        (F:'';L:48;C:3) BInitiated --> BEstablished Pickup[]/ (t48)
                        (F:'';L:47;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a47)
                        (F:'';L:57;C:3) BInitiated:precondition: (,state:Bob:currentState,!=,state:AIdle,), (a57)
                        (F:'';L:58;C:3) BInitiated:postcondition: (,state:Bob:currentState,!=,state:AInitiated,), (a58)
                        (F:'';L:59;C:3) BInitiated:invariant: (,state:Bob:currentState,!=,state:Aterminated,), (a59)
                    }
                    (F:'';L:0;C:0)
                    state Bterminated final:1;initial:0 {
                    }
                }
            }
            (F:'';L:3;C:1)
            state ClosedSystemEnvironment final:0;initial:0 {
                (F:'';L:4;C:1)
                -- r4 {
                    (F:'';L:0;C:0)
                    state AliceDial final:0;initial:1 {
                        (F:'';L:6;C:1) AliceDial --> BobPickup NullEvent[state:Alice:currentState,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t6)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state AliceHangup final:0;initial:0 {
                        (F:'';L:12;C:1) AliceHangup --> CallEnded NullEvent[state:Alice:currentState,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t12)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state BobPickup final:0;initial:0 {
                        (F:'';L:9;C:1) BobPickup --> AliceHangup NullEvent[state:Bob:currentState,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t9)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state CallEnded final:1;initial:0 {
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state ClosedSystemEnvironment final:0;initial:0 {
                        (F:'';L:17;C:1) ClosedSystemEnvironment:ltl: ltlFinalStates,{,<>,[],(,state:ClosedSystemEnvironment:currentState,==,state:CallEnded,&&,state:Alice:currentState,==,state:Aterminated,&&,state:Bob:currentState,==,state:Bterminated,),}, (a17)
                    }
                }
            }
        }
    } sip

*/

---- MODULE sip ----------------------------------------------------

EXTENDS TLC, Integers, Sequences

idx_Unknown == -1

idx_state_AEstablished == 1
idx_state_AIdle == 2
idx_state_AInitiated == 3
idx_state_Alice == 4
idx_state_AliceDial == 5
idx_state_AliceHangup == 6
idx_state_Aterminated == 7
idx_state_BEstablished == 8
idx_state_BIdle == 9
idx_state_BInitiated == 10
idx_state_Bob == 11
idx_state_BobPickup == 12
idx_state_Bterminated == 13
idx_state_CallEnded == 14
idx_state_ClosedSystemEnvironment == 15

idx_region_r22 == 1
idx_region_r3 == 2
idx_region_r4 == 3
idx_region_r44 == 4

idx_event_1xx == 10
idx_event_2xx == 11
idx_event_ACK == 12
idx_event_BYE == 13
idx_event_Dial == 5
idx_event_Hangup == 6
idx_event_INVITE == 14
idx_event_NullEvent == 8
idx_event_Pickup == 9

(**********************************************************************

--algorithm sip {

variables

    procs = { idx_region_r22, idx_region_r3, idx_region_r4, idx_region_r44 };
    channels = [p \in procs |-> <<>>];
    currentState = [p \in procs |-> idx_Unknown];
    stateTransitions = { "t30", "t23", "t26", "t27", "t51", "t52", "t45", "t48", "t6", "t12", "t9" };
    visitedTransitions = [t \in stateTransitions |-> FALSE];
    maxUmlEvents = -20;  \* limit the number of UML events in the run

\* Add to the Properties box of the model
define {
    \* Limit the number of UML events to maxUmlEvents; if reached this will show as a model run error
    MaxEventsReached == 
        /\ [](maxUmlEvents < 0)
    \* Flag dead transitions as errors
    AllTransitionsVisited == 
        /\ <>(\A t \in DOMAIN visitedTransitions : visitedTransitions[t] = TRUE)
    \* As extracted from the plantuml spec:
    UmlInvariants == 
        /\ [](TRUE) \* ensure not empty
    
        \*     (F:'';L:38;C:3) AInitiated:invariant: (,state:Alice:currentState,!=,state:Bterminated,), (a38)
        /\ []((currentState[idx_region_r22] /=idx_state_Bterminated))

        \*     (F:'';L:59;C:3) BInitiated:invariant: (,state:Bob:currentState,!=,state:Aterminated,), (a59)
        /\ []((currentState[idx_region_r44] /=idx_state_Aterminated))
}; 


macro send_event(channel, evtId, fromState, toState) {
    print <<"P:", fromState, "o->", evtId, channel, " > P:", toState>>;
    channels[channel] := Append(@, evtId);
    maxUmlEvents := maxUmlEvents + 1;
}
macro recv_event(evtId, channel, inState) {
    await Len(channels[channel]) > 0;
    evtId := Head(channels[channel]);
    print <<"P:", channel, inState, "<-i", evtId>>;
    channels[channel] := Tail(@);
}

    

fair+ process (region_r3 \in {idx_region_r3}) \* sip
variables
    evtRecv = idx_Unknown; 
    initialState = idx_Unknown; 
    finalState = idx_Unknown; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r3: currentState[self] := initialState;

\* state idx_state_Alice[

entry_Alice: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_Alice: skip;
    if ( noChannel = FALSE ) {
        L1:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_Alice


\* state idx_state_Bob[

entry_Bob: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_Bob: skip;
    if ( noChannel = FALSE ) {
        L2:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_Bob


\* state idx_state_ClosedSystemEnvironment[

entry_ClosedSystemEnvironment: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_ClosedSystemEnvironment: skip;
    if ( noChannel = FALSE ) {
        L3:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_ClosedSystemEnvironment

} \* region_r3 sip


fair+ process (region_r22 \in {idx_region_r22}) \* Alice
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_AIdle; 
    finalState = idx_state_Aterminated; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r22: currentState[self] := initialState;

\* state idx_state_AIdle[

entry_AIdle: skip;
    currentState[self] := newState;


body_AIdle: skip;
loop_AIdle: skip;
    if ( noChannel = FALSE ) {
        L4:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_AIdle[ 
    L5:
    \* either {

        \*     (F:'';L:23;C:3) AIdle --> AInitiated Dial[]/ (t23)
        await (evtRecv = idx_event_Dial);
        visitedTransitions["t23"] := TRUE;

        newState := idx_state_AInitiated; 
        goto entry_AInitiated;

    \* }; \* either
    \*]transitions idx_state_AIdle

\*]state idx_state_AIdle


\* state idx_state_AEstablished[

entry_AEstablished: skip;
    currentState[self] := newState;

    \*     (F:'';L:29;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a29)
    L6:send_event(idx_region_r44, idx_event_ACK, idx_state_AEstablished, idx_state_Bob); 


body_AEstablished: skip;
    if ( noChannel = FALSE ) {
        L7:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_AEstablished[ 
    L8:
    \* either {

        \*     (F:'';L:30;C:3) AEstablished --> Aterminated Hangup[]/ (t30)
        await (evtRecv = idx_event_Hangup);
        visitedTransitions["t30"] := TRUE;

        newState := idx_state_Aterminated; 
        goto entry_Aterminated;

    \* }; \* either
    \*]transitions idx_state_AEstablished

\*]state idx_state_AEstablished


\* state idx_state_AInitiated[

entry_AInitiated: skip;
    currentState[self] := newState;

    \*     (F:'';L:36;C:3) AInitiated:precondition: (,state:Alice:currentState,!=,state:BIdle,), (a36)
    L9: assert((currentState[idx_region_r22] /=idx_state_BIdle));

    \*     (F:'';L:25;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a25)
    L10:send_event(idx_region_r44, idx_event_INVITE, idx_state_AInitiated, idx_state_Bob); 


body_AInitiated: skip;
    if ( noChannel = FALSE ) {
        L11:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_AInitiated[ 
    L12:
    either {

        \*     (F:'';L:26;C:3) AInitiated --> AInitiated 1xx[]/ (t26)
        await (evtRecv = idx_event_1xx);
        visitedTransitions["t26"] := TRUE;

        \*     (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)

        L13: assert((currentState[idx_region_r22] /=idx_state_BInitiated));

        newState := idx_state_AInitiated; 
        goto body_AInitiated;

    } or {

        \*     (F:'';L:27;C:3) AInitiated --> AEstablished 2xx[]/ (t27)
        await (evtRecv = idx_event_2xx);
        visitedTransitions["t27"] := TRUE;

        \*     (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)

        L14: assert((currentState[idx_region_r22] /=idx_state_BInitiated));

        newState := idx_state_AEstablished; 
        goto entry_AEstablished;

    }; \* either
    \*]transitions idx_state_AInitiated

        \*     (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)

        L15: assert((currentState[idx_region_r22] /=idx_state_BInitiated));

        \*     (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)

        L16: assert((currentState[idx_region_r22] /=idx_state_BInitiated));

\*]state idx_state_AInitiated


\* state idx_state_Aterminated[

entry_Aterminated: skip;
    currentState[self] := newState;
    noChannel := TRUE;

    \*     (F:'';L:32;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a32)
    L17:send_event(idx_region_r44, idx_event_BYE, idx_state_Aterminated, idx_state_Bob); 


body_Aterminated: skip;
loop_Aterminated: skip;
    if ( noChannel = FALSE ) {
end_Aterminated: skip;
        L18:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_Aterminated

} \* region_r22 Alice


fair+ process (region_r44 \in {idx_region_r44}) \* Bob
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_BIdle; 
    finalState = idx_state_Bterminated; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r44: currentState[self] := initialState;

\* state idx_state_BIdle[

entry_BIdle: skip;
    currentState[self] := newState;


body_BIdle: skip;
loop_BIdle: skip;
    if ( noChannel = FALSE ) {
        L19:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_BIdle[ 
    L20:
    \* either {

        \*     (F:'';L:45;C:3) BIdle --> BInitiated INVITE[]/ (t45)
        await (evtRecv = idx_event_INVITE);
        visitedTransitions["t45"] := TRUE;

        newState := idx_state_BInitiated; 
        goto entry_BInitiated;

    \* }; \* either
    \*]transitions idx_state_BIdle

\*]state idx_state_BIdle


\* state idx_state_BEstablished[

entry_BEstablished: skip;
    currentState[self] := newState;

    \*     (F:'';L:50;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a50)
    L21:send_event(idx_region_r22, idx_event_2xx, idx_state_BEstablished, idx_state_Alice); 


body_BEstablished: skip;
    if ( noChannel = FALSE ) {
        L22:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_BEstablished[ 
    L23:
    either {

        \*     (F:'';L:51;C:3) BEstablished --> BEstablished ACK[]/ (t51)
        await (evtRecv = idx_event_ACK);
        visitedTransitions["t51"] := TRUE;

        newState := idx_state_BEstablished; 
        goto body_BEstablished;

    } or {

        \*     (F:'';L:52;C:3) BEstablished --> Bterminated BYE[]/ (t52)
        await (evtRecv = idx_event_BYE);
        visitedTransitions["t52"] := TRUE;

        newState := idx_state_Bterminated; 
        goto entry_Bterminated;

    }; \* either
    \*]transitions idx_state_BEstablished

\*]state idx_state_BEstablished


\* state idx_state_BInitiated[

entry_BInitiated: skip;
    currentState[self] := newState;

    \*     (F:'';L:57;C:3) BInitiated:precondition: (,state:Bob:currentState,!=,state:AIdle,), (a57)
    L24: assert((currentState[idx_region_r44] /=idx_state_AIdle));

    \*     (F:'';L:47;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a47)
    L25:send_event(idx_region_r22, idx_event_1xx, idx_state_BInitiated, idx_state_Alice); 


body_BInitiated: skip;
    if ( noChannel = FALSE ) {
        L26:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_BInitiated[ 
    L27:
    \* either {

        \*     (F:'';L:48;C:3) BInitiated --> BEstablished Pickup[]/ (t48)
        await (evtRecv = idx_event_Pickup);
        visitedTransitions["t48"] := TRUE;

        \*     (F:'';L:58;C:3) BInitiated:postcondition: (,state:Bob:currentState,!=,state:AInitiated,), (a58)

        L28: assert((currentState[idx_region_r44] /=idx_state_AInitiated));

        newState := idx_state_BEstablished; 
        goto entry_BEstablished;

    \* }; \* either
    \*]transitions idx_state_BInitiated

        \*     (F:'';L:58;C:3) BInitiated:postcondition: (,state:Bob:currentState,!=,state:AInitiated,), (a58)

        L29: assert((currentState[idx_region_r44] /=idx_state_AInitiated));

        \*     (F:'';L:58;C:3) BInitiated:postcondition: (,state:Bob:currentState,!=,state:AInitiated,), (a58)

        L30: assert((currentState[idx_region_r44] /=idx_state_AInitiated));

\*]state idx_state_BInitiated


\* state idx_state_Bterminated[

entry_Bterminated: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_Bterminated: skip;
loop_Bterminated: skip;
    if ( noChannel = FALSE ) {
end_Bterminated: skip;
        L31:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_Bterminated

} \* region_r44 Bob


fair+ process (region_r4 \in {idx_region_r4}) \* ClosedSystemEnvironment
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_AliceDial; 
    finalState = idx_state_CallEnded; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r4: currentState[self] := initialState;

\* state idx_state_AliceDial[

entry_AliceDial: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_AliceDial: skip;
loop_AliceDial: skip;
    if ( noChannel = FALSE ) {
        L32:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_AliceDial[ 
    L33:
    \* either {

        \*     (F:'';L:6;C:1) AliceDial --> BobPickup NullEvent[state:Alice:currentState,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t6)
        await (evtRecv = idx_event_NullEvent /\ currentState[idx_region_r22] =idx_state_AIdle);L34:send_event(idx_region_r22, idx_event_Dial, idx_state_AliceDial, idx_state_Alice); 

        visitedTransitions["t6"] := TRUE;

        newState := idx_state_BobPickup; 
        goto entry_BobPickup;

    \* }; \* either
    \*]transitions idx_state_AliceDial

\*]state idx_state_AliceDial


\* state idx_state_AliceHangup[

entry_AliceHangup: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_AliceHangup: skip;
    if ( noChannel = FALSE ) {
        L35:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_AliceHangup[ 
    L36:
    \* either {

        \*     (F:'';L:12;C:1) AliceHangup --> CallEnded NullEvent[state:Alice:currentState,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t12)
        await (evtRecv = idx_event_NullEvent /\ currentState[idx_region_r22] =idx_state_AEstablished);L37:send_event(idx_region_r22, idx_event_Hangup, idx_state_AliceHangup, idx_state_Alice); 

        visitedTransitions["t12"] := TRUE;

        newState := idx_state_CallEnded; 
        goto entry_CallEnded;

    \* }; \* either
    \*]transitions idx_state_AliceHangup

\*]state idx_state_AliceHangup


\* state idx_state_BobPickup[

entry_BobPickup: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_BobPickup: skip;
    if ( noChannel = FALSE ) {
        L38:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_BobPickup[ 
    L39:
    \* either {

        \*     (F:'';L:9;C:1) BobPickup --> AliceHangup NullEvent[state:Bob:currentState,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t9)
        await (evtRecv = idx_event_NullEvent /\ currentState[idx_region_r44] =idx_state_BInitiated);L40:send_event(idx_region_r44, idx_event_Pickup, idx_state_BobPickup, idx_state_Bob); 

        visitedTransitions["t9"] := TRUE;

        newState := idx_state_AliceHangup; 
        goto entry_AliceHangup;

    \* }; \* either
    \*]transitions idx_state_BobPickup

\*]state idx_state_BobPickup


\* state idx_state_ClosedSystemEnvironment[

entry_ClosedSystemEnvironment: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_ClosedSystemEnvironment: skip;
    if ( noChannel = FALSE ) {
        L41:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_ClosedSystemEnvironment


\* state idx_state_CallEnded[

entry_CallEnded: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_CallEnded: skip;
loop_CallEnded: skip;
    if ( noChannel = FALSE ) {
end_CallEnded: skip;
        L42:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_CallEnded

} \* region_r4 ClosedSystemEnvironment


} \* algorithm sip

**********************************************************************)

\*     (F:'';L:17;C:1) ClosedSystemEnvironment:ltl: ltlFinalStates,{,<>,[],(,state:ClosedSystemEnvironment:currentState,==,state:CallEnded,&&,state:Alice:currentState,==,state:Aterminated,&&,state:Bob:currentState,==,state:Bterminated,),}, (a17)
ltlFinalStates == <> [] ( currentState[idx_region_r4]  = idx_state_CallEnded /\ currentState[idx_region_r22]  = idx_state_Aterminated /\ currentState[idx_region_r44]  = idx_state_Bterminated ) 
 

\* Weakly fair scheduling 
(* PlusCal options (wf) *) 


=======================================================================
