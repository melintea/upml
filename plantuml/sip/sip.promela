/*
./upml --in ../plantuml/sip/sip.plantuml --backend spin --out ../plantuml/sip/sip.promela 
*/
/*
   Generated by UPML v0.06
   Mon Dec 16 20:28:30 2024


    (F:'';L:1;C:1)
    machine sip {
        (F:'';L:3;C:1)
        -- r3 {
            (F:'';L:21;C:1)
            state Alice final:0;initial:0 {
                (F:'';L:22;C:3)
                -- r22 {
                    (F:'';L:0;C:0)
                    state AEstablished final:0;initial:0 {
                        (F:'';L:30;C:3) AEstablished --> Aterminated Hangup[]/ (t30)
                        (F:'';L:29;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a29)
                    }
                    (F:'';L:0;C:0)
                    state AIdle final:0;initial:1 {
                        (F:'';L:23;C:3) AIdle --> AInitiated Dial[]/ (t23)
                    }
                    (F:'';L:0;C:0)
                    state AInitiated final:0;initial:0 {
                        (F:'';L:26;C:3) AInitiated --> AInitiated 1xx[]/ (t26)
                        (F:'';L:27;C:3) AInitiated --> AEstablished 2xx[]/ (t27)
                        (F:'';L:25;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a25)
                        (F:'';L:36;C:3) AInitiated:precondition: (,currentState:Alice,!=,state:BIdle,), (a36)
                        (F:'';L:37;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a37)
                        (F:'';L:38;C:3) AInitiated:invariant: (,currentState:Alice,!=,state:Bterminated,), (a38)
                    }
                    (F:'';L:0;C:0)
                    state Aterminated final:1;initial:0 {
                        (F:'';L:32;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a32)
                    }
                }
            }
            (F:'';L:43;C:1)
            state Bob final:0;initial:0 {
                (F:'';L:44;C:3)
                -- r44 {
                    (F:'';L:0;C:0)
                    state BEstablished final:0;initial:0 {
                        (F:'';L:51;C:3) BEstablished --> BEstablished ACK[]/ (t51)
                        (F:'';L:52;C:3) BEstablished --> Bterminated BYE[]/ (t52)
                        (F:'';L:50;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a50)
                    }
                    (F:'';L:0;C:0)
                    state BIdle final:0;initial:1 {
                        (F:'';L:45;C:3) BIdle --> BInitiated INVITE[]/ (t45)
                    }
                    (F:'';L:0;C:0)
                    state BInitiated final:0;initial:0 {
                        (F:'';L:48;C:3) BInitiated --> BEstablished Pickup[]/ (t48)
                        (F:'';L:47;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a47)
                        (F:'';L:57;C:3) BInitiated:precondition: (,currentState:Bob,!=,state:AIdle,), (a57)
                        (F:'';L:58;C:3) BInitiated:postcondition: (,currentState:Bob,!=,state:AInitiated,), (a58)
                        (F:'';L:59;C:3) BInitiated:invariant: (,currentState:Bob,!=,state:Aterminated,), (a59)
                    }
                    (F:'';L:0;C:0)
                    state Bterminated final:1;initial:0 {
                    }
                }
            }
            (F:'';L:3;C:1)
            state ClosedSystemEnvironment final:0;initial:0 {
                (F:'';L:4;C:1)
                -- r4 {
                    (F:'';L:0;C:0)
                    state AliceDial final:0;initial:1 {
                        (F:'';L:6;C:1) AliceDial --> BobPickup NullEvent[currentState:Alice,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t6)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state AliceHangup final:0;initial:0 {
                        (F:'';L:12;C:1) AliceHangup --> CallEnded NullEvent[currentState:Alice,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t12)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state BobPickup final:0;initial:0 {
                        (F:'';L:9;C:1) BobPickup --> AliceHangup NullEvent[currentState:Bob,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t9)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state CallEnded final:1;initial:0 {
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state ClosedSystemEnvironment final:0;initial:0 {
                        (F:'';L:17;C:1) ClosedSystemEnvironment:ltl: ltlFinalStates,{,<>,[],(,currentState:ClosedSystemEnvironment,==,state:CallEnded,&&,currentState:Alice,==,state:Aterminated,&&,currentState:Bob,==,state:Bterminated,),}, (a17)
                    }
                }
            }
        }
    } sip

*/


#define idx_unknown -1

#define idx_state_AEstablished 0
#define idx_state_AIdle 1
#define idx_state_AInitiated 2
#define idx_state_Alice 3
#define idx_state_AliceDial 4
#define idx_state_AliceHangup 5
#define idx_state_Aterminated 6
#define idx_state_BEstablished 7
#define idx_state_BIdle 8
#define idx_state_BInitiated 9
#define idx_state_Bob 10
#define idx_state_BobPickup 11
#define idx_state_Bterminated 12
#define idx_state_CallEnded 13
#define idx_state_ClosedSystemEnvironment 14

#define idx_region_r22 0
#define idx_region_r3 1
#define idx_region_r4 2
#define idx_region_r44 3

mtype = { event_1xx, event_2xx, event_ACK, event_BYE, event_Dial, event_Hangup, event_INVITE, event_NullEvent, event_Pickup, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[4] = [4] of {event};

inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_r3() // sip
{
    local short myIdx = idx_region_r3;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_unknown; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_Alice[*/

entry_Alice:
    currentState = newState;
    noChannel = true;


body_Alice:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Alice*/


/* state idx_state_Bob[*/

entry_Bob:
    currentState = newState;
    noChannel = true;


body_Bob:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Bob*/


/* state idx_state_ClosedSystemEnvironment[*/

entry_ClosedSystemEnvironment:
    currentState = newState;
    noChannel = true;


body_ClosedSystemEnvironment:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_ClosedSystemEnvironment*/

} // region_r3 sip


proctype region_r22() // Alice
{
    local short myIdx = idx_region_r22;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_AIdle; 
    local short finalState = idx_state_Aterminated; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_AIdle[*/

entry_AIdle:
    currentState = newState;


body_AIdle:
loop_AIdle:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AIdle[*/
    if

        //    (F:'';L:23;C:3) AIdle --> AInitiated Dial[]/ (t23)
        :: (evtRecv.evId == event_Dial) -> 
            newState = idx_state_AInitiated; 
            goto entry_AInitiated;

    fi
    /*]transitions idx_state_AIdle*/

/*]state idx_state_AIdle*/


/* state idx_state_AEstablished[*/

entry_AEstablished:
    currentState = newState;

    //    (F:'';L:29;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a29)
    send_event(idx_region_r44, event_ACK, idx_state_AEstablished, idx_state_Bob); 


body_AEstablished:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AEstablished[*/
    if

        //    (F:'';L:30;C:3) AEstablished --> Aterminated Hangup[]/ (t30)
        :: (evtRecv.evId == event_Hangup) -> 
            newState = idx_state_Aterminated; 
            goto entry_Aterminated;

    fi
    /*]transitions idx_state_AEstablished*/

/*]state idx_state_AEstablished*/


/* state idx_state_AInitiated[*/

entry_AInitiated:
    currentState = newState;

    //    (F:'';L:36;C:3) AInitiated:precondition: (,currentState:Alice,!=,state:BIdle,), (a36)
    assert(( region_r22:currentState != idx_state_BIdle ) );

    //    (F:'';L:25;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a25)
    send_event(idx_region_r44, event_INVITE, idx_state_AInitiated, idx_state_Bob); 


body_AInitiated:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AInitiated[*/
    if

        //    (F:'';L:26;C:3) AInitiated --> AInitiated 1xx[]/ (t26)
        :: (evtRecv.evId == event_1xx) -> 
    //    (F:'';L:37;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a37)
    assert(( region_r22:currentState != idx_state_BInitiated ) );

            newState = idx_state_AInitiated; 
            goto body_AInitiated;

        //    (F:'';L:27;C:3) AInitiated --> AEstablished 2xx[]/ (t27)
        :: (evtRecv.evId == event_2xx) -> 
    //    (F:'';L:37;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a37)
    assert(( region_r22:currentState != idx_state_BInitiated ) );

            newState = idx_state_AEstablished; 
            goto entry_AEstablished;

    fi
    /*]transitions idx_state_AInitiated*/

    //    (F:'';L:37;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a37)
    assert(( region_r22:currentState != idx_state_BInitiated ) );

    //    (F:'';L:37;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a37)
    assert(( region_r22:currentState != idx_state_BInitiated ) );

/*]state idx_state_AInitiated*/


/* state idx_state_Aterminated[*/

entry_Aterminated:
    currentState = newState;
    noChannel = true;

    //    (F:'';L:32;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a32)
    send_event(idx_region_r44, event_BYE, idx_state_Aterminated, idx_state_Bob); 


body_Aterminated:
loop_Aterminated:
    if
    :: ( noChannel == false ) ->
end_Aterminated:
        myChan?evtRecv; 
        printf("MSC: > %d region_r22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Aterminated*/

} // region_r22 Alice


proctype region_r44() // Bob
{
    local short myIdx = idx_region_r44;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_BIdle; 
    local short finalState = idx_state_Bterminated; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_BIdle[*/

entry_BIdle:
    currentState = newState;


body_BIdle:
loop_BIdle:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r44 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BIdle[*/
    if

        //    (F:'';L:45;C:3) BIdle --> BInitiated INVITE[]/ (t45)
        :: (evtRecv.evId == event_INVITE) -> 
            newState = idx_state_BInitiated; 
            goto entry_BInitiated;

    fi
    /*]transitions idx_state_BIdle*/

/*]state idx_state_BIdle*/


/* state idx_state_BEstablished[*/

entry_BEstablished:
    currentState = newState;

    //    (F:'';L:50;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a50)
    send_event(idx_region_r22, event_2xx, idx_state_BEstablished, idx_state_Alice); 


body_BEstablished:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r44 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BEstablished[*/
    if

        //    (F:'';L:51;C:3) BEstablished --> BEstablished ACK[]/ (t51)
        :: (evtRecv.evId == event_ACK) -> 
            newState = idx_state_BEstablished; 
            goto body_BEstablished;

        //    (F:'';L:52;C:3) BEstablished --> Bterminated BYE[]/ (t52)
        :: (evtRecv.evId == event_BYE) -> 
            newState = idx_state_Bterminated; 
            goto entry_Bterminated;

    fi
    /*]transitions idx_state_BEstablished*/

/*]state idx_state_BEstablished*/


/* state idx_state_BInitiated[*/

entry_BInitiated:
    currentState = newState;

    //    (F:'';L:57;C:3) BInitiated:precondition: (,currentState:Bob,!=,state:AIdle,), (a57)
    assert(( region_r44:currentState != idx_state_AIdle ) );

    //    (F:'';L:47;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a47)
    send_event(idx_region_r22, event_1xx, idx_state_BInitiated, idx_state_Alice); 


body_BInitiated:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r44 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BInitiated[*/
    if

        //    (F:'';L:48;C:3) BInitiated --> BEstablished Pickup[]/ (t48)
        :: (evtRecv.evId == event_Pickup) -> 
    //    (F:'';L:58;C:3) BInitiated:postcondition: (,currentState:Bob,!=,state:AInitiated,), (a58)
    assert(( region_r44:currentState != idx_state_AInitiated ) );

            newState = idx_state_BEstablished; 
            goto entry_BEstablished;

    fi
    /*]transitions idx_state_BInitiated*/

    //    (F:'';L:58;C:3) BInitiated:postcondition: (,currentState:Bob,!=,state:AInitiated,), (a58)
    assert(( region_r44:currentState != idx_state_AInitiated ) );

    //    (F:'';L:58;C:3) BInitiated:postcondition: (,currentState:Bob,!=,state:AInitiated,), (a58)
    assert(( region_r44:currentState != idx_state_AInitiated ) );

/*]state idx_state_BInitiated*/


/* state idx_state_Bterminated[*/

entry_Bterminated:
    currentState = newState;
    noChannel = true;


body_Bterminated:
loop_Bterminated:
    if
    :: ( noChannel == false ) ->
end_Bterminated:
        myChan?evtRecv; 
        printf("MSC: > %d region_r44 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Bterminated*/

} // region_r44 Bob


proctype region_r4() // ClosedSystemEnvironment
{
    local short myIdx = idx_region_r4;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_AliceDial; 
    local short finalState = idx_state_CallEnded; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_AliceDial[*/

entry_AliceDial:
    currentState = newState;
    noChannel = true;


body_AliceDial:
loop_AliceDial:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AliceDial[*/
    if

        //    (F:'';L:6;C:1) AliceDial --> BobPickup NullEvent[currentState:Alice,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t6)
        :: (evtRecv.evId == event_NullEvent && region_r22:currentState == idx_state_AIdle ) -> send_event(idx_region_r22, event_Dial, idx_state_AliceDial, idx_state_Alice); 

            newState = idx_state_BobPickup; 
            goto entry_BobPickup;

    fi
    /*]transitions idx_state_AliceDial*/

/*]state idx_state_AliceDial*/


/* state idx_state_AliceHangup[*/

entry_AliceHangup:
    currentState = newState;
    noChannel = true;


body_AliceHangup:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AliceHangup[*/
    if

        //    (F:'';L:12;C:1) AliceHangup --> CallEnded NullEvent[currentState:Alice,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t12)
        :: (evtRecv.evId == event_NullEvent && region_r22:currentState == idx_state_AEstablished ) -> send_event(idx_region_r22, event_Hangup, idx_state_AliceHangup, idx_state_Alice); 

            newState = idx_state_CallEnded; 
            goto entry_CallEnded;

    fi
    /*]transitions idx_state_AliceHangup*/

/*]state idx_state_AliceHangup*/


/* state idx_state_BobPickup[*/

entry_BobPickup:
    currentState = newState;
    noChannel = true;


body_BobPickup:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BobPickup[*/
    if

        //    (F:'';L:9;C:1) BobPickup --> AliceHangup NullEvent[currentState:Bob,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t9)
        :: (evtRecv.evId == event_NullEvent && region_r44:currentState == idx_state_BInitiated ) -> send_event(idx_region_r44, event_Pickup, idx_state_BobPickup, idx_state_Bob); 

            newState = idx_state_AliceHangup; 
            goto entry_AliceHangup;

    fi
    /*]transitions idx_state_BobPickup*/

/*]state idx_state_BobPickup*/


/* state idx_state_ClosedSystemEnvironment[*/

entry_ClosedSystemEnvironment:
    currentState = newState;
    noChannel = true;


body_ClosedSystemEnvironment:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_ClosedSystemEnvironment*/


/* state idx_state_CallEnded[*/

entry_CallEnded:
    currentState = newState;
    noChannel = true;


body_CallEnded:
loop_CallEnded:
    if
    :: ( noChannel == false ) ->
end_CallEnded:
        myChan?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_CallEnded*/

} // region_r4 ClosedSystemEnvironment


proctype invariants() {
end_invariants:
progress_invariants:
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement

    //    (F:'';L:38;C:3) AInitiated:invariant: (,currentState:Alice,!=,state:Bterminated,), (a38)
    :: atomic { !(( region_r22:currentState != idx_state_Bterminated ) ) -> assert(( region_r22:currentState != idx_state_Bterminated ) ) };

    //    (F:'';L:59;C:3) BInitiated:invariant: (,currentState:Bob,!=,state:Aterminated,), (a59)
    :: atomic { !(( region_r44:currentState != idx_state_Aterminated ) ) -> assert(( region_r44:currentState != idx_state_Aterminated ) ) };

    od
}


init {
    atomic {
        run region_r22(); 
        run region_r3(); 
        run region_r4(); 
        run region_r44(); 
        run invariants(); 
    }
    //(_nr_pr == 1); 
}


// ltl claims: run with spin -ltl xyz or spin -noclaim 
//     (F:'';L:17;C:1) ClosedSystemEnvironment:ltl: ltlFinalStates,{,<>,[],(,currentState:ClosedSystemEnvironment,==,state:CallEnded,&&,currentState:Alice,==,state:Aterminated,&&,currentState:Bob,==,state:Bterminated,),}, (a17)
ltl ltlFinalStates  {  <>  []  (  region_r4:currentState  ==  idx_state_CallEnded  &&  region_r22:currentState  ==  idx_state_Aterminated  &&  region_r44:currentState  ==  idx_state_Bterminated  )  }  ;
 

/*UPML end*/

