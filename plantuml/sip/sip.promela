/*
./upml --in ../plantuml/sip/sip.plantuml --backend spin --out ../plantuml/sip/sip.promela 
*/
/*
   Generated by UPML v0.01
   Thu Jun 20 14:37:40 2024


    (F:'';L:1;C:1)
    machine m1 {
        (F:'';L:3;C:1)
        -- r3 {
            (F:'';L:13;C:1)
            state Alice final:0;initial:0 {
                (F:'';L:14;C:3)
                -- r14 {
                    (F:'';L:0;C:0)
                    state AEstablished final:0;initial:0 {
                        (F:'';L:27;C:3) AEstablished --> Aterminated Hangup[]/ (t27)
                        (F:'';L:26;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a26)
                    }
                    (F:'';L:0;C:0)
                    state AIdle final:0;initial:1 {
                        (F:'';L:15;C:3) AIdle --> AInitiated Dial[]/ (t15)
                    }
                    (F:'';L:0;C:0)
                    state AInitiated final:0;initial:0 {
                        (F:'';L:18;C:3) AInitiated --> AInitiated 1xx[]/ (t18)
                        (F:'';L:19;C:3) AInitiated --> AEstablished 2xx[]/ (t19)
                        (F:'';L:17;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a17)
                    }
                    (F:'';L:0;C:0)
                    state Aterminated final:1;initial:0 {
                        (F:'';L:29;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a29)
                    }
                }
            }
            (F:'';L:35;C:1)
            state Bob final:0;initial:0 {
                (F:'';L:36;C:3)
                -- r36 {
                    (F:'';L:0;C:0)
                    state BEstablished final:0;initial:0 {
                        (F:'';L:43;C:3) BEstablished --> BEstablished ACK[]/ (t43)
                        (F:'';L:44;C:3) BEstablished --> Bterminated BYE[]/ (t44)
                        (F:'';L:42;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a42)
                    }
                    (F:'';L:0;C:0)
                    state BIdle final:0;initial:1 {
                        (F:'';L:37;C:3) BIdle --> BInitiated INVITE[]/ (t37)
                    }
                    (F:'';L:0;C:0)
                    state BInitiated final:0;initial:0 {
                        (F:'';L:40;C:3) BInitiated --> BEstablished Pickup[]/ (t40)
                        (F:'';L:39;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a39)
                    }
                    (F:'';L:0;C:0)
                    state Bterminated final:1;initial:0 {
                    }
                }
            }
            (F:'';L:3;C:1)
            state ClosedSystemEnvironment final:0;initial:0 {
                (F:'';L:4;C:1)
                -- r4 {
                    (F:'';L:0;C:0)
                    state StateMachineEventGenerator final:0;initial:1 {
                        (F:'';L:7;C:1) StateMachineEventGenerator --> StateMachineEventGenerator NullEvent[currentState:Alice,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t7)
                        (F:'';L:8;C:1) StateMachineEventGenerator --> StateMachineEventGenerator NullEvent[currentState:Bob,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t8)
                        (F:'';L:9;C:1) StateMachineEventGenerator --> StateMachineEventGenerator NullEvent[currentState:Alice,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t9)
                        noInboundEvents,
                    }
                }
            }
        }
    } m1

*/


#define idx_unknown -1

#define idx_state_AEstablished 0
#define idx_state_AIdle 1
#define idx_state_AInitiated 2
#define idx_state_Alice 3
#define idx_state_Aterminated 4
#define idx_state_BEstablished 5
#define idx_state_BIdle 6
#define idx_state_BInitiated 7
#define idx_state_Bob 8
#define idx_state_Bterminated 9
#define idx_state_ClosedSystemEnvironment 10
#define idx_state_StateMachineEventGenerator 11

#define idx_region_r14 0
#define idx_region_r3 1
#define idx_region_r36 2
#define idx_region_r4 3

mtype = { event_1xx, event_2xx, event_ACK, event_BYE, event_Dial, event_Hangup, event_INVITE, event_NullEvent, event_Pickup, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[4] = [4] of {event};

inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_r3() // m1
{
    local short myIdx = idx_region_r3;
    local event evtRecv; 
    local short initialState = idx_unknown; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_Alice[*/

entry_Alice:
    currentState = newState;

body_Alice:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Alice*/


/* state idx_state_Bob[*/

entry_Bob:
    currentState = newState;

body_Bob:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Bob*/


/* state idx_state_ClosedSystemEnvironment[*/

entry_ClosedSystemEnvironment:
    currentState = newState;

body_ClosedSystemEnvironment:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_ClosedSystemEnvironment*/

} // region_r3 m1


proctype region_r14() // Alice
{
    local short myIdx = idx_region_r14;
    local event evtRecv; 
    local short initialState = idx_state_AIdle; 
    local short finalState = idx_state_Aterminated; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_AIdle[*/

entry_AIdle:
    currentState = newState;

body_AIdle:
loop_AIdle:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r14 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AIdle[*/
    if

            //    (F:'';L:15;C:3) AIdle --> AInitiated Dial[]/ (t15)

            :: (evtRecv.evId == event_Dial) -> 
            newState = idx_state_AInitiated; 
            goto entry_AInitiated;

    fi
    /*]transitions idx_state_AIdle*/

/*]state idx_state_AIdle*/


/* state idx_state_AEstablished[*/

entry_AEstablished:
    currentState = newState;
    //    (F:'';L:26;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a26)

     send_event(idx_region_r36, event_ACK, idx_state_AEstablished, idx_state_Bob); 


body_AEstablished:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r14 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AEstablished[*/
    if

            //    (F:'';L:27;C:3) AEstablished --> Aterminated Hangup[]/ (t27)

            :: (evtRecv.evId == event_Hangup) -> 
            newState = idx_state_Aterminated; 
            goto entry_Aterminated;

    fi
    /*]transitions idx_state_AEstablished*/

/*]state idx_state_AEstablished*/


/* state idx_state_AInitiated[*/

entry_AInitiated:
    currentState = newState;
    //    (F:'';L:17;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a17)

     send_event(idx_region_r36, event_INVITE, idx_state_AInitiated, idx_state_Bob); 


body_AInitiated:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r14 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AInitiated[*/
    if

            //    (F:'';L:18;C:3) AInitiated --> AInitiated 1xx[]/ (t18)

            :: (evtRecv.evId == event_1xx) -> 
            newState = idx_state_AInitiated; 
            goto body_AInitiated;

            //    (F:'';L:19;C:3) AInitiated --> AEstablished 2xx[]/ (t19)

            :: (evtRecv.evId == event_2xx) -> 
            newState = idx_state_AEstablished; 
            goto entry_AEstablished;

    fi
    /*]transitions idx_state_AInitiated*/

/*]state idx_state_AInitiated*/


/* state idx_state_Aterminated[*/

entry_Aterminated:
    currentState = newState;
    //    (F:'';L:29;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a29)

     send_event(idx_region_r36, event_BYE, idx_state_Aterminated, idx_state_Bob); 


body_Aterminated:
loop_Aterminated:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r14 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Aterminated*/

} // region_r14 Alice


proctype region_r36() // Bob
{
    local short myIdx = idx_region_r36;
    local event evtRecv; 
    local short initialState = idx_state_BIdle; 
    local short finalState = idx_state_Bterminated; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_BIdle[*/

entry_BIdle:
    currentState = newState;

body_BIdle:
loop_BIdle:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r36 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BIdle[*/
    if

            //    (F:'';L:37;C:3) BIdle --> BInitiated INVITE[]/ (t37)

            :: (evtRecv.evId == event_INVITE) -> 
            newState = idx_state_BInitiated; 
            goto entry_BInitiated;

    fi
    /*]transitions idx_state_BIdle*/

/*]state idx_state_BIdle*/


/* state idx_state_BEstablished[*/

entry_BEstablished:
    currentState = newState;
    //    (F:'';L:42;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a42)

     send_event(idx_region_r14, event_2xx, idx_state_BEstablished, idx_state_Alice); 


body_BEstablished:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r36 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BEstablished[*/
    if

            //    (F:'';L:43;C:3) BEstablished --> BEstablished ACK[]/ (t43)

            :: (evtRecv.evId == event_ACK) -> 
            newState = idx_state_BEstablished; 
            goto body_BEstablished;

            //    (F:'';L:44;C:3) BEstablished --> Bterminated BYE[]/ (t44)

            :: (evtRecv.evId == event_BYE) -> 
            newState = idx_state_Bterminated; 
            goto entry_Bterminated;

    fi
    /*]transitions idx_state_BEstablished*/

/*]state idx_state_BEstablished*/


/* state idx_state_BInitiated[*/

entry_BInitiated:
    currentState = newState;
    //    (F:'';L:39;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a39)

     send_event(idx_region_r14, event_1xx, idx_state_BInitiated, idx_state_Alice); 


body_BInitiated:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r36 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BInitiated[*/
    if

            //    (F:'';L:40;C:3) BInitiated --> BEstablished Pickup[]/ (t40)

            :: (evtRecv.evId == event_Pickup) -> 
            newState = idx_state_BEstablished; 
            goto entry_BEstablished;

    fi
    /*]transitions idx_state_BInitiated*/

/*]state idx_state_BInitiated*/


/* state idx_state_Bterminated[*/

entry_Bterminated:
    currentState = newState;

body_Bterminated:
loop_Bterminated:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r36 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Bterminated*/

} // region_r36 Bob


proctype region_r4() // ClosedSystemEnvironment
{
    local short myIdx = idx_region_r4;
    local event evtRecv; 
    local short initialState = idx_state_StateMachineEventGenerator; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_StateMachineEventGenerator[*/

entry_StateMachineEventGenerator:
    currentState = newState;
    noChannel = true;

body_StateMachineEventGenerator:
loop_StateMachineEventGenerator:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_StateMachineEventGenerator[*/
    if

            //    (F:'';L:7;C:1) StateMachineEventGenerator --> StateMachineEventGenerator NullEvent[currentState:Alice,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t7)

            :: (evtRecv.evId == event_NullEvent && region_r14:currentState == idx_state_AIdle ) ->  send_event(idx_region_r14, event_Dial, idx_state_StateMachineEventGenerator, idx_state_Alice); 

            newState = idx_state_StateMachineEventGenerator; 
            goto body_StateMachineEventGenerator;

            //    (F:'';L:8;C:1) StateMachineEventGenerator --> StateMachineEventGenerator NullEvent[currentState:Bob,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t8)

            :: (evtRecv.evId == event_NullEvent && region_r36:currentState == idx_state_BInitiated ) ->  send_event(idx_region_r36, event_Pickup, idx_state_StateMachineEventGenerator, idx_state_Bob); 

            newState = idx_state_StateMachineEventGenerator; 
            goto body_StateMachineEventGenerator;

            //    (F:'';L:9;C:1) StateMachineEventGenerator --> StateMachineEventGenerator NullEvent[currentState:Alice,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t9)

            :: (evtRecv.evId == event_NullEvent && region_r14:currentState == idx_state_AEstablished ) ->  send_event(idx_region_r14, event_Hangup, idx_state_StateMachineEventGenerator, idx_state_Alice); 

            newState = idx_state_StateMachineEventGenerator; 
            goto body_StateMachineEventGenerator;

    fi
    /*]transitions idx_state_StateMachineEventGenerator*/

/*]state idx_state_StateMachineEventGenerator*/

} // region_r4 ClosedSystemEnvironment

init {
    atomic {
        run region_r14(); 
        run region_r3(); 
        run region_r36(); 
        run region_r4(); 
    }
}

/*UPML end*/

