/*
./upml --add-monitor=false --in ../plantuml/sip/sip.plantuml --backend spin --out ../plantuml/sip/sip.promela 
*/
/*
   Generated by UPML v0.01
   Tue May 28 13:09:41 2024


    (F:'';L:1;C:1)
    machine m1 {
        (F:'';L:11;C:1)
        -- r11 {
            (F:'';L:19;C:1)
            state Alice final:0;initial:0 {
                (F:'';L:20;C:3)
                -- r20 {
                    (F:'';L:0;C:0)
                    state AEstablished final:0;initial:0 {
                        (F:'';L:33;C:3) AEstablished --> Aterminated Hangup[]/ (t33)
                        (F:'';L:32;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a32)
                    }
                    (F:'';L:0;C:0)
                    state AIdle final:0;initial:1 {
                        (F:'';L:21;C:3) AIdle --> AInitiated Dial[]/ (t21)
                    }
                    (F:'';L:0;C:0)
                    state AInitiated final:0;initial:0 {
                        (F:'';L:24;C:3) AInitiated --> AInitiated 1xx[]/ (t24)
                        (F:'';L:25;C:3) AInitiated --> AEstablished 2xx[]/ (t25)
                        (F:'';L:23;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a23)
                    }
                    (F:'';L:0;C:0)
                    state Aterminated final:1;initial:0 {
                        (F:'';L:35;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a35)
                    }
                }
            }
            (F:'';L:41;C:1)
            state Bob final:0;initial:0 {
                (F:'';L:42;C:3)
                -- r42 {
                    (F:'';L:0;C:0)
                    state BEstablished final:0;initial:0 {
                        (F:'';L:49;C:3) BEstablished --> BEstablished ACK[]/ (t49)
                        (F:'';L:50;C:3) BEstablished --> Bterminated BYE[]/ (t50)
                        (F:'';L:48;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a48)
                    }
                    (F:'';L:0;C:0)
                    state BIdle final:0;initial:1 {
                        (F:'';L:43;C:3) BIdle --> BInitiated INVITE[]/ (t43)
                    }
                    (F:'';L:0;C:0)
                    state BInitiated final:0;initial:0 {
                        (F:'';L:46;C:3) BInitiated --> BEstablished Pickup[]/ (t46)
                        (F:'';L:45;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a45)
                    }
                    (F:'';L:0;C:0)
                    state Bterminated final:1;initial:0 {
                    }
                }
            }
            (F:'';L:0;C:0)
            state StateMachineEventGenerator final:0;initial:1 {
                (F:'';L:14;C:1) StateMachineEventGenerator --> StateMachineEventGenerator StateChange[evtRecv.fromState,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t14)
                (F:'';L:15;C:1) StateMachineEventGenerator --> StateMachineEventGenerator StateChange[evtRecv.fromState,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t15)
                (F:'';L:12;C:1) StateMachineEventGenerator:entry: send,event:Dial,to,state:Alice, (a12)
            }
        }
    } m1

*/


#define idx_unknown -1

#define idx_state_AEstablished 0
#define idx_state_AIdle 1
#define idx_state_AInitiated 2
#define idx_state_Alice 3
#define idx_state_Aterminated 4
#define idx_state_BEstablished 5
#define idx_state_BIdle 6
#define idx_state_BInitiated 7
#define idx_state_Bob 8
#define idx_state_Bterminated 9
#define idx_state_StateMachineEventGenerator 10

#define idx_region_r11 0
#define idx_region_r20 1
#define idx_region_r42 2

mtype = { event_1xx, event_2xx, event_ACK, event_BYE, event_Dial, event_Hangup, event_INVITE, event_Pickup, event_StateChange, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[3] = [3] of {event};

inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

never {
    do
    :: assert( 1 == 1 ); // never clause cannot be empty
    od
} // never



proctype region_r11() // m1
{
    local short myIdx = idx_region_r11;
    local event evtRecv; 
    local short initialState = idx_state_StateMachineEventGenerator; 
    local short finalState = idx_unknown; 
    local short crtState = initialState; 
    local short newState = initialState; 
    bool terminate = false; 


/* state idx_state_StateMachineEventGenerator[*/

entry_StateMachineEventGenerator:
    //    (F:'';L:12;C:1) StateMachineEventGenerator:entry: send,event:Dial,to,state:Alice, (a12)

     send_event(idx_region_r11, event_Dial, idx_state_StateMachineEventGenerator, idx_state_Alice); 


body_StateMachineEventGenerator:
    /* transitions idx_state_StateMachineEventGenerator[*/
    if

            //    (F:'';L:14;C:1) StateMachineEventGenerator --> StateMachineEventGenerator StateChange[evtRecv.fromState,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t14)

            :: (evtRecv.evId == event_StateChange && evtRecv.fromState == idx_state_BInitiated ) ->  send_event(idx_region_r11, event_Pickup, idx_state_StateMachineEventGenerator, idx_state_Bob); 

            newState = idx_state_StateMachineEventGenerator; 
            goto body_StateMachineEventGenerator;

            //    (F:'';L:15;C:1) StateMachineEventGenerator --> StateMachineEventGenerator StateChange[evtRecv.fromState,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t15)

            :: (evtRecv.evId == event_StateChange && evtRecv.fromState == idx_state_AEstablished ) ->  send_event(idx_region_r11, event_Hangup, idx_state_StateMachineEventGenerator, idx_state_Alice); 

            newState = idx_state_StateMachineEventGenerator; 
            goto body_StateMachineEventGenerator;

    fi
    /*]transitions idx_state_StateMachineEventGenerator*/

/*]state idx_state_StateMachineEventGenerator*/


/* state idx_state_Alice[*/

entry_Alice:

body_Alice:
    _channels[myIdx]?evtRecv; 
    printf("MSC: > %d region_r11 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 


/*]state idx_state_Alice*/


/* state idx_state_Bob[*/

entry_Bob:

body_Bob:
    _channels[myIdx]?evtRecv; 
    printf("MSC: > %d region_r11 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 


/*]state idx_state_Bob*/

} // region_r11 m1


proctype region_r20() // Alice
{
    local short myIdx = idx_region_r20;
    local event evtRecv; 
    local short initialState = idx_state_AIdle; 
    local short finalState = idx_state_Aterminated; 
    local short crtState = initialState; 
    local short newState = initialState; 
    bool terminate = false; 


/* state idx_state_AIdle[*/

entry_AIdle:

body_AIdle:
    /* transitions idx_state_AIdle[*/
    if

            //    (F:'';L:21;C:3) AIdle --> AInitiated Dial[]/ (t21)

            :: (evtRecv.evId == event_Dial) -> 
            newState = idx_state_AInitiated; 
            goto entry_AInitiated;

    fi
    /*]transitions idx_state_AIdle*/

/*]state idx_state_AIdle*/


/* state idx_state_AEstablished[*/

entry_AEstablished:
    //    (F:'';L:32;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a32)

     send_event(idx_region_r11, event_ACK, idx_state_AEstablished, idx_state_Bob); 


body_AEstablished:
    _channels[myIdx]?evtRecv; 
    printf("MSC: > %d region_r20 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 


    /* transitions idx_state_AEstablished[*/
    if

            //    (F:'';L:33;C:3) AEstablished --> Aterminated Hangup[]/ (t33)

            :: (evtRecv.evId == event_Hangup) -> 
            newState = idx_state_Aterminated; 
            goto entry_Aterminated;

    fi
    /*]transitions idx_state_AEstablished*/

/*]state idx_state_AEstablished*/


/* state idx_state_AInitiated[*/

entry_AInitiated:
    //    (F:'';L:23;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a23)

     send_event(idx_region_r11, event_INVITE, idx_state_AInitiated, idx_state_Bob); 


body_AInitiated:
    _channels[myIdx]?evtRecv; 
    printf("MSC: > %d region_r20 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 


    /* transitions idx_state_AInitiated[*/
    if

            //    (F:'';L:24;C:3) AInitiated --> AInitiated 1xx[]/ (t24)

            :: (evtRecv.evId == event_1xx) -> 
            newState = idx_state_AInitiated; 
            goto body_AInitiated;

            //    (F:'';L:25;C:3) AInitiated --> AEstablished 2xx[]/ (t25)

            :: (evtRecv.evId == event_2xx) -> 
            newState = idx_state_AEstablished; 
            goto entry_AEstablished;

    fi
    /*]transitions idx_state_AInitiated*/

/*]state idx_state_AInitiated*/


/* state idx_state_Aterminated[*/

entry_Aterminated:
    //    (F:'';L:35;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a35)

     send_event(idx_region_r11, event_BYE, idx_state_Aterminated, idx_state_Bob); 


body_Aterminated:
    _channels[myIdx]?evtRecv; 
    printf("MSC: > %d region_r20 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 


/*]state idx_state_Aterminated*/

} // region_r20 Alice


proctype region_r42() // Bob
{
    local short myIdx = idx_region_r42;
    local event evtRecv; 
    local short initialState = idx_state_BIdle; 
    local short finalState = idx_state_Bterminated; 
    local short crtState = initialState; 
    local short newState = initialState; 
    bool terminate = false; 


/* state idx_state_BIdle[*/

entry_BIdle:

body_BIdle:
    /* transitions idx_state_BIdle[*/
    if

            //    (F:'';L:43;C:3) BIdle --> BInitiated INVITE[]/ (t43)

            :: (evtRecv.evId == event_INVITE) -> 
            newState = idx_state_BInitiated; 
            goto entry_BInitiated;

    fi
    /*]transitions idx_state_BIdle*/

/*]state idx_state_BIdle*/


/* state idx_state_BEstablished[*/

entry_BEstablished:
    //    (F:'';L:48;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a48)

     send_event(idx_region_r11, event_2xx, idx_state_BEstablished, idx_state_Alice); 


body_BEstablished:
    _channels[myIdx]?evtRecv; 
    printf("MSC: > %d region_r42 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 


    /* transitions idx_state_BEstablished[*/
    if

            //    (F:'';L:49;C:3) BEstablished --> BEstablished ACK[]/ (t49)

            :: (evtRecv.evId == event_ACK) -> 
            newState = idx_state_BEstablished; 
            goto body_BEstablished;

            //    (F:'';L:50;C:3) BEstablished --> Bterminated BYE[]/ (t50)

            :: (evtRecv.evId == event_BYE) -> 
            newState = idx_state_Bterminated; 
            goto entry_Bterminated;

    fi
    /*]transitions idx_state_BEstablished*/

/*]state idx_state_BEstablished*/


/* state idx_state_BInitiated[*/

entry_BInitiated:
    //    (F:'';L:45;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a45)

     send_event(idx_region_r11, event_1xx, idx_state_BInitiated, idx_state_Alice); 


body_BInitiated:
    _channels[myIdx]?evtRecv; 
    printf("MSC: > %d region_r42 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 


    /* transitions idx_state_BInitiated[*/
    if

            //    (F:'';L:46;C:3) BInitiated --> BEstablished Pickup[]/ (t46)

            :: (evtRecv.evId == event_Pickup) -> 
            newState = idx_state_BEstablished; 
            goto entry_BEstablished;

    fi
    /*]transitions idx_state_BInitiated*/

/*]state idx_state_BInitiated*/


/* state idx_state_Bterminated[*/

entry_Bterminated:

body_Bterminated:
    _channels[myIdx]?evtRecv; 
    printf("MSC: > %d region_r42 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 


/*]state idx_state_Bterminated*/

} // region_r42 Bob

init {
    atomic {
        run region_r11(); 
        run region_r20(); 
        run region_r42(); 
    }
}

/*UPML end*/

