/*
./upml --in ../plantuml/sip/sip.plantuml --backend spin --out ../plantuml/sip/sip.promela 
*/
/*
   Generated by UPML v0.01
   Fri Jun 28 10:53:35 2024


    (F:'';L:1;C:1)
    machine m1 {
        (F:'';L:3;C:1)
        -- r3 {
            (F:'';L:19;C:1)
            state Alice final:0;initial:0 {
                (F:'';L:20;C:3)
                -- r20 {
                    (F:'';L:0;C:0)
                    state AEstablished final:0;initial:0 {
                        (F:'';L:28;C:3) AEstablished --> Aterminated Hangup[]/ (t28)
                        (F:'';L:27;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a27)
                    }
                    (F:'';L:0;C:0)
                    state AIdle final:0;initial:1 {
                        (F:'';L:21;C:3) AIdle --> AInitiated Dial[]/ (t21)
                    }
                    (F:'';L:0;C:0)
                    state AInitiated final:0;initial:0 {
                        (F:'';L:24;C:3) AInitiated --> AInitiated 1xx[]/ (t24)
                        (F:'';L:25;C:3) AInitiated --> AEstablished 2xx[]/ (t25)
                        (F:'';L:23;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a23)
                        (F:'';L:34;C:3) AInitiated:precondition: (,currentState:Alice,!=,state:BIdle,), (a34)
                        (F:'';L:35;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a35)
                        (F:'';L:36;C:3) AInitiated:invariant: (,currentState:Alice,!=,state:Bterminated,), (a36)
                    }
                    (F:'';L:0;C:0)
                    state Aterminated final:1;initial:0 {
                        (F:'';L:30;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a30)
                    }
                }
            }
            (F:'';L:41;C:1)
            state Bob final:0;initial:0 {
                (F:'';L:42;C:3)
                -- r42 {
                    (F:'';L:0;C:0)
                    state BEstablished final:0;initial:0 {
                        (F:'';L:49;C:3) BEstablished --> BEstablished ACK[]/ (t49)
                        (F:'';L:50;C:3) BEstablished --> Bterminated BYE[]/ (t50)
                        (F:'';L:48;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a48)
                    }
                    (F:'';L:0;C:0)
                    state BIdle final:0;initial:1 {
                        (F:'';L:43;C:3) BIdle --> BInitiated INVITE[]/ (t43)
                    }
                    (F:'';L:0;C:0)
                    state BInitiated final:0;initial:0 {
                        (F:'';L:46;C:3) BInitiated --> BEstablished Pickup[]/ (t46)
                        (F:'';L:45;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a45)
                        (F:'';L:55;C:3) BInitiated:precondition: (,currentState:Bob,!=,state:AIdle,), (a55)
                        (F:'';L:56;C:3) BInitiated:postcondition: (,currentState:Bob,!=,state:AInitiated,), (a56)
                        (F:'';L:57;C:3) BInitiated:invariant: (,currentState:Bob,!=,state:Aterminated,), (a57)
                    }
                    (F:'';L:0;C:0)
                    state Bterminated final:1;initial:0 {
                    }
                }
            }
            (F:'';L:3;C:1)
            state ClosedSystemEnvironment final:0;initial:0 {
                (F:'';L:4;C:1)
                -- r4 {
                    (F:'';L:0;C:0)
                    state AliceDial final:0;initial:1 {
                        (F:'';L:6;C:1) AliceDial --> BobPickup NullEvent[currentState:Alice,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t6)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state AliceHangup final:0;initial:0 {
                        (F:'';L:12;C:1) AliceHangup --> CallEnded NullEvent[currentState:Alice,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t12)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state BobPickup final:0;initial:0 {
                        (F:'';L:9;C:1) BobPickup --> AliceHangup NullEvent[currentState:Bob,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t9)
                        noInboundEvents,
                    }
                    (F:'';L:0;C:0)
                    state CallEnded final:1;initial:0 {
                        noInboundEvents,
                    }
                }
            }
        }
    } m1

*/


#define idx_unknown -1

#define idx_state_AEstablished 0
#define idx_state_AIdle 1
#define idx_state_AInitiated 2
#define idx_state_Alice 3
#define idx_state_AliceDial 4
#define idx_state_AliceHangup 5
#define idx_state_Aterminated 6
#define idx_state_BEstablished 7
#define idx_state_BIdle 8
#define idx_state_BInitiated 9
#define idx_state_Bob 10
#define idx_state_BobPickup 11
#define idx_state_Bterminated 12
#define idx_state_CallEnded 13
#define idx_state_ClosedSystemEnvironment 14

#define idx_region_r20 0
#define idx_region_r3 1
#define idx_region_r4 2
#define idx_region_r42 3

mtype = { event_1xx, event_2xx, event_ACK, event_BYE, event_Dial, event_Hangup, event_INVITE, event_NullEvent, event_Pickup, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[4] = [4] of {event};

inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_r3() // m1
{
    local short myIdx = idx_region_r3;
    local event evtRecv; 
    local short initialState = idx_unknown; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_Alice[*/

entry_Alice:
    currentState = newState;
    noChannel = true;

body_Alice:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Alice*/


/* state idx_state_Bob[*/

entry_Bob:
    currentState = newState;
    noChannel = true;

body_Bob:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Bob*/


/* state idx_state_ClosedSystemEnvironment[*/

entry_ClosedSystemEnvironment:
    currentState = newState;
    noChannel = true;

body_ClosedSystemEnvironment:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_ClosedSystemEnvironment*/

} // region_r3 m1


proctype region_r20() // Alice
{
    local short myIdx = idx_region_r20;
    local event evtRecv; 
    local short initialState = idx_state_AIdle; 
    local short finalState = idx_state_Aterminated; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_AIdle[*/

entry_AIdle:
    currentState = newState;

body_AIdle:
loop_AIdle:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r20 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AIdle[*/
    if

            //    (F:'';L:21;C:3) AIdle --> AInitiated Dial[]/ (t21)

            :: (evtRecv.evId == event_Dial) -> 
            newState = idx_state_AInitiated; 
            goto entry_AInitiated;

    fi
    /*]transitions idx_state_AIdle*/

/*]state idx_state_AIdle*/


/* state idx_state_AEstablished[*/

entry_AEstablished:
    currentState = newState;
    //    (F:'';L:27;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a27)

     send_event(idx_region_r42, event_ACK, idx_state_AEstablished, idx_state_Bob); 


body_AEstablished:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r20 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AEstablished[*/
    if

            //    (F:'';L:28;C:3) AEstablished --> Aterminated Hangup[]/ (t28)

            :: (evtRecv.evId == event_Hangup) -> 
            newState = idx_state_Aterminated; 
            goto entry_Aterminated;

    fi
    /*]transitions idx_state_AEstablished*/

/*]state idx_state_AEstablished*/


/* state idx_state_AInitiated[*/

entry_AInitiated:
    currentState = newState;
        //    (F:'';L:34;C:3) AInitiated:precondition: (,currentState:Alice,!=,state:BIdle,), (a34)
        assert(( region_r20:currentState != idx_state_BIdle ) );

    //    (F:'';L:23;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a23)

     send_event(idx_region_r42, event_INVITE, idx_state_AInitiated, idx_state_Bob); 


body_AInitiated:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r20 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AInitiated[*/
    if

            //    (F:'';L:24;C:3) AInitiated --> AInitiated 1xx[]/ (t24)

            :: (evtRecv.evId == event_1xx) -> 
        //    (F:'';L:35;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a35)
        assert(( region_r20:currentState != idx_state_BInitiated ) );

            newState = idx_state_AInitiated; 
            goto body_AInitiated;

            //    (F:'';L:25;C:3) AInitiated --> AEstablished 2xx[]/ (t25)

            :: (evtRecv.evId == event_2xx) -> 
        //    (F:'';L:35;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a35)
        assert(( region_r20:currentState != idx_state_BInitiated ) );

            newState = idx_state_AEstablished; 
            goto entry_AEstablished;

    fi
    /*]transitions idx_state_AInitiated*/

        //    (F:'';L:35;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a35)
        assert(( region_r20:currentState != idx_state_BInitiated ) );

        //    (F:'';L:35;C:3) AInitiated:postcondition: (,currentState:Alice,!=,state:BInitiated,), (a35)
        assert(( region_r20:currentState != idx_state_BInitiated ) );

/*]state idx_state_AInitiated*/


/* state idx_state_Aterminated[*/

entry_Aterminated:
    currentState = newState;
    noChannel = true;
    //    (F:'';L:30;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a30)

     send_event(idx_region_r42, event_BYE, idx_state_Aterminated, idx_state_Bob); 


body_Aterminated:
loop_Aterminated:
    if
    :: ( noChannel == false ) ->
end_Aterminated:
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r20 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Aterminated*/

} // region_r20 Alice


proctype region_r42() // Bob
{
    local short myIdx = idx_region_r42;
    local event evtRecv; 
    local short initialState = idx_state_BIdle; 
    local short finalState = idx_state_Bterminated; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_BIdle[*/

entry_BIdle:
    currentState = newState;

body_BIdle:
loop_BIdle:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r42 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BIdle[*/
    if

            //    (F:'';L:43;C:3) BIdle --> BInitiated INVITE[]/ (t43)

            :: (evtRecv.evId == event_INVITE) -> 
            newState = idx_state_BInitiated; 
            goto entry_BInitiated;

    fi
    /*]transitions idx_state_BIdle*/

/*]state idx_state_BIdle*/


/* state idx_state_BEstablished[*/

entry_BEstablished:
    currentState = newState;
    //    (F:'';L:48;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a48)

     send_event(idx_region_r20, event_2xx, idx_state_BEstablished, idx_state_Alice); 


body_BEstablished:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r42 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BEstablished[*/
    if

            //    (F:'';L:49;C:3) BEstablished --> BEstablished ACK[]/ (t49)

            :: (evtRecv.evId == event_ACK) -> 
            newState = idx_state_BEstablished; 
            goto body_BEstablished;

            //    (F:'';L:50;C:3) BEstablished --> Bterminated BYE[]/ (t50)

            :: (evtRecv.evId == event_BYE) -> 
            newState = idx_state_Bterminated; 
            goto entry_Bterminated;

    fi
    /*]transitions idx_state_BEstablished*/

/*]state idx_state_BEstablished*/


/* state idx_state_BInitiated[*/

entry_BInitiated:
    currentState = newState;
        //    (F:'';L:55;C:3) BInitiated:precondition: (,currentState:Bob,!=,state:AIdle,), (a55)
        assert(( region_r42:currentState != idx_state_AIdle ) );

    //    (F:'';L:45;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a45)

     send_event(idx_region_r20, event_1xx, idx_state_BInitiated, idx_state_Alice); 


body_BInitiated:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r42 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BInitiated[*/
    if

            //    (F:'';L:46;C:3) BInitiated --> BEstablished Pickup[]/ (t46)

            :: (evtRecv.evId == event_Pickup) -> 
        //    (F:'';L:56;C:3) BInitiated:postcondition: (,currentState:Bob,!=,state:AInitiated,), (a56)
        assert(( region_r42:currentState != idx_state_AInitiated ) );

            newState = idx_state_BEstablished; 
            goto entry_BEstablished;

    fi
    /*]transitions idx_state_BInitiated*/

        //    (F:'';L:56;C:3) BInitiated:postcondition: (,currentState:Bob,!=,state:AInitiated,), (a56)
        assert(( region_r42:currentState != idx_state_AInitiated ) );

        //    (F:'';L:56;C:3) BInitiated:postcondition: (,currentState:Bob,!=,state:AInitiated,), (a56)
        assert(( region_r42:currentState != idx_state_AInitiated ) );

/*]state idx_state_BInitiated*/


/* state idx_state_Bterminated[*/

entry_Bterminated:
    currentState = newState;
    noChannel = true;

body_Bterminated:
loop_Bterminated:
    if
    :: ( noChannel == false ) ->
end_Bterminated:
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r42 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Bterminated*/

} // region_r42 Bob


proctype region_r4() // ClosedSystemEnvironment
{
    local short myIdx = idx_region_r4;
    local event evtRecv; 
    local short initialState = idx_state_AliceDial; 
    local short finalState = idx_state_CallEnded; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_AliceDial[*/

entry_AliceDial:
    currentState = newState;
    noChannel = true;

body_AliceDial:
loop_AliceDial:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AliceDial[*/
    if

            //    (F:'';L:6;C:1) AliceDial --> BobPickup NullEvent[currentState:Alice,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t6)

            :: (evtRecv.evId == event_NullEvent && region_r20:currentState == idx_state_AIdle ) ->  send_event(idx_region_r20, event_Dial, idx_state_AliceDial, idx_state_Alice); 

            newState = idx_state_BobPickup; 
            goto entry_BobPickup;

    fi
    /*]transitions idx_state_AliceDial*/

/*]state idx_state_AliceDial*/


/* state idx_state_AliceHangup[*/

entry_AliceHangup:
    currentState = newState;
    noChannel = true;

body_AliceHangup:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_AliceHangup[*/
    if

            //    (F:'';L:12;C:1) AliceHangup --> CallEnded NullEvent[currentState:Alice,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t12)

            :: (evtRecv.evId == event_NullEvent && region_r20:currentState == idx_state_AEstablished ) ->  send_event(idx_region_r20, event_Hangup, idx_state_AliceHangup, idx_state_Alice); 

            newState = idx_state_CallEnded; 
            goto entry_CallEnded;

    fi
    /*]transitions idx_state_AliceHangup*/

/*]state idx_state_AliceHangup*/


/* state idx_state_BobPickup[*/

entry_BobPickup:
    currentState = newState;
    noChannel = true;

body_BobPickup:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BobPickup[*/
    if

            //    (F:'';L:9;C:1) BobPickup --> AliceHangup NullEvent[currentState:Bob,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t9)

            :: (evtRecv.evId == event_NullEvent && region_r42:currentState == idx_state_BInitiated ) ->  send_event(idx_region_r42, event_Pickup, idx_state_BobPickup, idx_state_Bob); 

            newState = idx_state_AliceHangup; 
            goto entry_AliceHangup;

    fi
    /*]transitions idx_state_BobPickup*/

/*]state idx_state_BobPickup*/


/* state idx_state_CallEnded[*/

entry_CallEnded:
    currentState = newState;
    noChannel = true;

body_CallEnded:
loop_CallEnded:
    if
    :: ( noChannel == false ) ->
end_CallEnded:
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_CallEnded*/

} // region_r4 ClosedSystemEnvironment


proctype invariants() {
end_invariants:
progress_invariants:
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement
    //    (F:'';L:36;C:3) AInitiated:invariant: (,currentState:Alice,!=,state:Bterminated,), (a36)

    :: (( region_r20:currentState != idx_state_Bterminated ) ) -> assert(( region_r20:currentState != idx_state_Bterminated ) );

    //    (F:'';L:57;C:3) BInitiated:invariant: (,currentState:Bob,!=,state:Aterminated,), (a57)

    :: (( region_r42:currentState != idx_state_Aterminated ) ) -> assert(( region_r42:currentState != idx_state_Aterminated ) );

    od
}


init {
    atomic {
        run region_r20(); 
        run region_r3(); 
        run region_r4(); 
        run region_r42(); 
        run invariants(); 
    }
}

/*UPML end*/

