/*
./upml --in ../plantuml/switch/switch.plantuml --backend tla --out ../plantuml/switch/switch.tla 
*/
/*
   Generated by UPML v0.03
   Mon Jul  8 11:57:51 2024


    (F:'';L:1;C:1)
    machine switch {
        (F:'';L:17;C:1)
        -- r17 {
            (F:'';L:17;C:1)
            state Human final:0;initial:0 {
                (F:'';L:19;C:1)
                -- r19 {
                    (F:'';L:0;C:0)
                    state Flip final:0;initial:1 {
                        (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)
                        (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)
                        noInboundEvents,
                    }
                }
            }
            (F:'';L:28;C:1)
            state Switch final:0;initial:0 {
                (F:'';L:30;C:1)
                -- r30 {
                    (F:'';L:0;C:0)
                    state BothOff final:0;initial:1 {
                        (F:'';L:32;C:1) BothOff --> WallOff LampSwitch[]/ (t32)
                        (F:'';L:35;C:1) BothOff --> LampOff WallSwitch[]/ (t35)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state LampOff final:0;initial:0 {
                        (F:'';L:36;C:1) LampOff --> BothOff WallSwitch[]/ (t36)
                        (F:'';L:43;C:1) LampOff --> On LampSwitch[]/ (t43)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state On final:0;initial:0 {
                        (F:'';L:40;C:1) On --> WallOff LampSwitch[]/ (t40)
                        (F:'';L:46;C:1) On --> LampOff WallSwitch[]/ (t46)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state WallOff final:0;initial:0 {
                        (F:'';L:33;C:1) WallOff --> BothOff LampSwitch[]/ (t33)
                        (F:'';L:39;C:1) WallOff --> On WallSwitch[]/ (t39)
                        progressTag,
                    }
                }
            }
        }
    } switch

*/

---- MODULE switch ----------------------------------------------------

EXTENDS TLC, Integers, Sequences

idx_unknown = -1

idx_state_BothOff = 1
idx_state_Flip = 2
idx_state_Human = 3
idx_state_LampOff = 4
idx_state_On = 5
idx_state_Switch = 6
idx_state_WallOff = 7

idx_region_r17 = 1
idx_region_r19 = 2
idx_region_r30 = 3

idx_event_LampSwitch = 1
idx_event_NullEvent = 2
idx_event_WallSwitch = 3

(**********************************************************************

--algorithm lamp {

variables

     channels = << <<>>, <<>>, <<>> >>;


macro send_event(evt, from, to) {
    print <<"P:", from, "o->", evt, " > P:", to>>;
    assert(from >= idx_proc_Min /\ from <= idx_proc_Max);
    assert(to >= idx_proc_Min /\ to <= idx_proc_Max);
    assert(evt >= idx_event_Min /\ evt <= idx_event_Max);
    channels[to] := Append(@, evt);
}
macro recv_event(evt, to) {
    assert(to >= idx_proc_Min /\ to <= idx_proc_Max);
    await Len(channels[to]) > 0;
    evt := Head(channels[to]);
    print <<"P:", to, "<-i", evt>>;
    assert(evt >= idx_event_Min /\ evt <= idx_event_Max);
    channels[to] := Tail(@);
}

    

fair+ process (region_r17 \in {idx_region_r17}) \* switch
    evtRecv = idx_unknown; 
    initialState = idx_unknown; 
    finalState = idx_unknown; 
    currentState = initialState; 
    newState = initialState; 
    noChannel = FALSE; 
{
} \* region_r17 switch


fair+ process (region_r19 \in {idx_region_r19}) \* Human
    evtRecv = idx_unknown; 
    initialState = idx_state_Flip; 
    finalState = idx_unknown; 
    currentState = initialState; 
    newState = initialState; 
    noChannel = FALSE; 
{
} \* region_r19 Human


fair+ process (region_r30 \in {idx_region_r30}) \* Switch
    evtRecv = idx_unknown; 
    initialState = idx_state_BothOff; 
    finalState = idx_unknown; 
    currentState = initialState; 
    newState = initialState; 
    noChannel = FALSE; 
{
} \* region_r30 Switch


} \* algorithm lamp

**********************************************************************)

