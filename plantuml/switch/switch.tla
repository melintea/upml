/*
./upml --in ../plantuml/switch/switch.plantuml --backend tla --out ../plantuml/switch/switch.tla 
*/
/*
   Generated by UPML v0.03
   Mon Jul  8 14:07:39 2024


    (F:'';L:1;C:1)
    machine switch {
        (F:'';L:17;C:1)
        -- r17 {
            (F:'';L:17;C:1)
            state Human final:0;initial:0 {
                (F:'';L:19;C:1)
                -- r19 {
                    (F:'';L:0;C:0)
                    state Flip final:0;initial:1 {
                        (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)
                        (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)
                        noInboundEvents,
                    }
                }
            }
            (F:'';L:28;C:1)
            state Switch final:0;initial:0 {
                (F:'';L:30;C:1)
                -- r30 {
                    (F:'';L:0;C:0)
                    state BothOff final:0;initial:1 {
                        (F:'';L:32;C:1) BothOff --> WallOff LampSwitch[]/ (t32)
                        (F:'';L:35;C:1) BothOff --> LampOff WallSwitch[]/ (t35)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state LampOff final:0;initial:0 {
                        (F:'';L:36;C:1) LampOff --> BothOff WallSwitch[]/ (t36)
                        (F:'';L:43;C:1) LampOff --> On LampSwitch[]/ (t43)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state On final:0;initial:0 {
                        (F:'';L:40;C:1) On --> WallOff LampSwitch[]/ (t40)
                        (F:'';L:46;C:1) On --> LampOff WallSwitch[]/ (t46)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state WallOff final:0;initial:0 {
                        (F:'';L:33;C:1) WallOff --> BothOff LampSwitch[]/ (t33)
                        (F:'';L:39;C:1) WallOff --> On WallSwitch[]/ (t39)
                        progressTag,
                    }
                }
            }
        }
    } switch

*/

---- MODULE switch ----------------------------------------------------

EXTENDS TLC, Integers, Sequences

idx_Unknown = -1

idx_state_BothOff = 1
idx_state_Flip = 2
idx_state_Human = 3
idx_state_LampOff = 4
idx_state_On = 5
idx_state_Switch = 6
idx_state_WallOff = 7

idx_region_r17 = 1
idx_region_r19 = 2
idx_region_r30 = 3

idx_event_LampSwitch = 1
idx_event_NullEvent = 2
idx_event_WallSwitch = 3

(**********************************************************************

--algorithm lamp {

variables

     channels = << <<>>, <<>>, <<>> >>;


macro send_event(evt, from, to) {
    print <<"P:", from, "o->", evt, " > P:", to>>;
    channels[to] := Append(@, evt);
}
macro recv_event(evt, to) {
    await Len(channels[to]) > 0;
    evt := Head(channels[to]);
    print <<"P:", to, "<-i", evt>>;
    channels[to] := Tail(@);
}

    

fair+ process (region_r17 \in {idx_region_r17}) \* switch
    evtRecv = idx_Unknown; 
    initialState = idx_Unknown; 
    finalState = idx_Unknown; 
    currentState = initialState; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body: skip;

\* state idx_state_Human[

entry_Human: skip;
    currentState = newState;
    noChannel = true;

body_Human: skip;
    if ( noChannel == false ) {
        _channels[self]?evtRecv; 
        printf("MSC: > %d region_r17 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    } else {
        evtRecv.evId = event_NullEvent;
    }


\*]state idx_state_Human


\* state idx_state_Switch[

entry_Switch: skip;
    currentState = newState;
    noChannel = true;

body_Switch: skip;
    if ( noChannel == false ) {
        _channels[self]?evtRecv; 
        printf("MSC: > %d region_r17 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    } else {
        evtRecv.evId = event_NullEvent;
    }


\*]state idx_state_Switch

} \* region_r17 switch


fair+ process (region_r19 \in {idx_region_r19}) \* Human
    evtRecv = idx_Unknown; 
    initialState = idx_state_Flip; 
    finalState = idx_Unknown; 
    currentState = initialState; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body: skip;

\* state idx_state_Flip[

entry_Flip: skip;
    currentState = newState;
    noChannel = true;

body_Flip: skip;
loop_Flip: skip;
    if ( noChannel == false ) {
        _channels[self]?evtRecv; 
        printf("MSC: > %d region_r19 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    } else {
        evtRecv.evId = event_NullEvent;
    }


    \* transitions idx_state_Flip[ 
    either {

            \*     (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)

            await (evtRecv.evId == event_NullEvent); 

            send_event(idx_region_r30, event_LampSwitch, idx_state_Flip, idx_state_Switch); 

            newState = idx_state_Flip; 
            goto body_Flip;

    } or {
            \*     (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)

            await (evtRecv.evId == event_NullEvent); 

            send_event(idx_region_r30, event_WallSwitch, idx_state_Flip, idx_state_Switch); 

            newState = idx_state_Flip; 
            goto body_Flip;

    } or {
    };
    \*]transitions idx_state_Flip

\*]state idx_state_Flip

} \* region_r19 Human


fair+ process (region_r30 \in {idx_region_r30}) \* Switch
    evtRecv = idx_Unknown; 
    initialState = idx_state_BothOff; 
    finalState = idx_Unknown; 
    currentState = initialState; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body: skip;

\* state idx_state_BothOff[

entry_BothOff: skip;
    currentState = newState;

body_BothOff: skip;
loop_BothOff: skip;
progress_BothOff: skip;
    if ( noChannel == false ) {
        _channels[self]?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    } else {
        evtRecv.evId = event_NullEvent;
    }


    \* transitions idx_state_BothOff[ 
    either {

            \*     (F:'';L:32;C:1) BothOff --> WallOff LampSwitch[]/ (t32)

            await (evtRecv.evId == event_LampSwitch); 

            
            newState = idx_state_WallOff; 
            goto entry_WallOff;

    } or {
            \*     (F:'';L:35;C:1) BothOff --> LampOff WallSwitch[]/ (t35)

            await (evtRecv.evId == event_WallSwitch); 

            
            newState = idx_state_LampOff; 
            goto entry_LampOff;

    } or {
    };
    \*]transitions idx_state_BothOff

\*]state idx_state_BothOff


\* state idx_state_LampOff[

entry_LampOff: skip;
    currentState = newState;

body_LampOff: skip;
progress_LampOff: skip;
    if ( noChannel == false ) {
        _channels[self]?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    } else {
        evtRecv.evId = event_NullEvent;
    }


    \* transitions idx_state_LampOff[ 
    either {

            \*     (F:'';L:36;C:1) LampOff --> BothOff WallSwitch[]/ (t36)

            await (evtRecv.evId == event_WallSwitch); 

            
            newState = idx_state_BothOff; 
            goto entry_BothOff;

    } or {
            \*     (F:'';L:43;C:1) LampOff --> On LampSwitch[]/ (t43)

            await (evtRecv.evId == event_LampSwitch); 

            
            newState = idx_state_On; 
            goto entry_On;

    } or {
    };
    \*]transitions idx_state_LampOff

\*]state idx_state_LampOff


\* state idx_state_On[

entry_On: skip;
    currentState = newState;

body_On: skip;
progress_On: skip;
    if ( noChannel == false ) {
        _channels[self]?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    } else {
        evtRecv.evId = event_NullEvent;
    }


    \* transitions idx_state_On[ 
    either {

            \*     (F:'';L:40;C:1) On --> WallOff LampSwitch[]/ (t40)

            await (evtRecv.evId == event_LampSwitch); 

            
            newState = idx_state_WallOff; 
            goto entry_WallOff;

    } or {
            \*     (F:'';L:46;C:1) On --> LampOff WallSwitch[]/ (t46)

            await (evtRecv.evId == event_WallSwitch); 

            
            newState = idx_state_LampOff; 
            goto entry_LampOff;

    } or {
    };
    \*]transitions idx_state_On

\*]state idx_state_On


\* state idx_state_WallOff[

entry_WallOff: skip;
    currentState = newState;

body_WallOff: skip;
progress_WallOff: skip;
    if ( noChannel == false ) {
        _channels[self]?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    } else {
        evtRecv.evId = event_NullEvent;
    }


    \* transitions idx_state_WallOff[ 
    either {

            \*     (F:'';L:33;C:1) WallOff --> BothOff LampSwitch[]/ (t33)

            await (evtRecv.evId == event_LampSwitch); 

            
            newState = idx_state_BothOff; 
            goto entry_BothOff;

    } or {
            \*     (F:'';L:39;C:1) WallOff --> On WallSwitch[]/ (t39)

            await (evtRecv.evId == event_WallSwitch); 

            
            newState = idx_state_On; 
            goto entry_On;

    } or {
    };
    \*]transitions idx_state_WallOff

\*]state idx_state_WallOff

} \* region_r30 Switch


} \* algorithm lamp

**********************************************************************)

