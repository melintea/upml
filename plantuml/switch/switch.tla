/*
./upml --in ../plantuml/switch/switch.plantuml --backend tla --out ../plantuml/switch/switch.tla 
*/
/*
   Generated by UPML v0.06
   Wed Mar 12 12:07:57 2025


    (F:'';L:1;C:1)
    machine switch {
        (F:'';L:17;C:1)
        -- r17 _ownedByState:m1 {
            (F:'';L:17;C:1)
            state Human final:0;initial:0;_superState:m1;_ownedByRegion:r17 {
                (F:'';L:19;C:1)
                -- r19 _ownedByState:Human {
                    (F:'';L:0;C:0)
                    state Flip final:0;initial:1;_superState:Human;_ownedByRegion:r19 {
                        (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)
                        (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)
                        noInboundEvents,
                    } Flip
                } r19
            } Human
            (F:'';L:28;C:1)
            state Switch final:0;initial:0;_superState:m1;_ownedByRegion:r17 {
                (F:'';L:30;C:1)
                -- r30 _ownedByState:Switch {
                    (F:'';L:0;C:0)
                    state BothOff final:0;initial:1;_superState:Switch;_ownedByRegion:r30 {
                        (F:'';L:32;C:1) BothOff --> WallOff LampSwitch[]/ (t32)
                        (F:'';L:35;C:1) BothOff --> LampOff WallSwitch[]/ (t35)
                        progressTag,
                    } BothOff
                    (F:'';L:0;C:0)
                    state LampOff final:0;initial:0;_superState:Switch;_ownedByRegion:r30 {
                        (F:'';L:36;C:1) LampOff --> BothOff WallSwitch[]/ (t36)
                        (F:'';L:43;C:1) LampOff --> On LampSwitch[]/ (t43)
                        progressTag,
                    } LampOff
                    (F:'';L:0;C:0)
                    state On final:0;initial:0;_superState:Switch;_ownedByRegion:r30 {
                        (F:'';L:40;C:1) On --> WallOff LampSwitch[]/ (t40)
                        (F:'';L:46;C:1) On --> LampOff WallSwitch[]/ (t46)
                        progressTag,
                    } On
                    (F:'';L:0;C:0)
                    state WallOff final:0;initial:0;_superState:Switch;_ownedByRegion:r30 {
                        (F:'';L:33;C:1) WallOff --> BothOff LampSwitch[]/ (t33)
                        (F:'';L:39;C:1) WallOff --> On WallSwitch[]/ (t39)
                        progressTag,
                    } WallOff
                } r30
            } Switch
        } r17
    } switch
    
*/

---- MODULE switch ----------------------------------------------------

EXTENDS TLC, Integers, Sequences

idx_Unknown == -1

idx_state_BothOff == 1
idx_state_Flip == 2
idx_state_Human == 3
idx_state_LampOff == 4
idx_state_On == 5
idx_state_Switch == 6
idx_state_WallOff == 7

idx_region_r17 == 1
idx_region_r19 == 2
idx_region_r30 == 3

idx_event_LampSwitch == 1
idx_event_NullEvent == 2
idx_event_WallSwitch == 3

(**********************************************************************

--algorithm switch {

variables
    
    procs = { idx_region_r17, idx_region_r19, idx_region_r30 };
    channels = [p \in procs |-> <<>>];
    currentState = [p \in procs |-> idx_Unknown];
    stateTransitions = { "t21", "t22", "t32", "t35", "t36", "t43", "t40", "t46", "t33", "t39" };
    visitedTransitions = [t \in stateTransitions |-> FALSE];
    maxUmlEvents = -20;  \* limit the number of UML events in the run

\* Add to the Properties box of the model
define {
    \* Limit the number of UML events to maxUmlEvents; if reached this will show as a model run error
    MaxEventsReached == 
        /\ [](maxUmlEvents < 0)
    \* Flag dead transitions as errors
    AllTransitionsVisited == 
        /\ <>(\A t \in DOMAIN visitedTransitions : visitedTransitions[t] = TRUE)
    \* As extracted from the plantuml spec:
    UmlInvariants == 
        /\ [](TRUE) \* ensure not empty
        
}; \* define 


macro send_event(channel, evtId, fromState, toState) {
    print <<"P:", fromState, "o->", evtId, channel, " > P:", toState>>;
    channels[channel] := Append(@, evtId);
    maxUmlEvents := maxUmlEvents + 1;
}
macro recv_event(evtId, channel, inState) {
    await Len(channels[channel]) > 0;
    evtId := Head(channels[channel]);
    print <<"P:", channel, inState, "<-i", evtId>>;
    channels[channel] := Tail(@);
}

    

fair+ process (region_r17 \in {idx_region_r17}) \* switch
variables
    evtRecv = idx_Unknown; 
    initialState = idx_Unknown; 
    finalState = idx_Unknown; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r17: currentState[self] := initialState;

\* state idx_state_Human[

entry_Human: skip;    
    currentState[self] := newState;
    noChannel := TRUE;
    

body_Human: skip;    
    if ( noChannel = FALSE ) { 
        L1:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };
    
    
\*]state idx_state_Human


\* state idx_state_Switch[

entry_Switch: skip;    
    currentState[self] := newState;
    noChannel := TRUE;
    

body_Switch: skip;    
    if ( noChannel = FALSE ) { 
        L2:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };
    
    
\*]state idx_state_Switch

} \* region_r17 switch


fair+ process (region_r19 \in {idx_region_r19}) \* Human
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_Flip; 
    finalState = idx_Unknown; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r19: currentState[self] := initialState;

\* state idx_state_Flip[

entry_Flip: skip;    
    currentState[self] := newState;
    noChannel := TRUE;
    

body_Flip: skip;
loop_Flip: skip;    
    if ( noChannel = FALSE ) { 
        L3:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };
    
    
    \* transitions idx_state_Flip[ 
    L4:
    either {    
        
        \*     (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)
        await (evtRecv = idx_event_NullEvent);L5:send_event(idx_region_r30, idx_event_LampSwitch, idx_state_Flip, idx_state_Switch); 
        
        visitedTransitions["t21"] := TRUE;
        
        newState := idx_state_Flip; 
        goto body_Flip;
        
    } or {    
        
        \*     (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)
        await (evtRecv = idx_event_NullEvent);L6:send_event(idx_region_r30, idx_event_WallSwitch, idx_state_Flip, idx_state_Switch); 
        
        visitedTransitions["t22"] := TRUE;
        
        newState := idx_state_Flip; 
        goto body_Flip;
        
    }; \* either
    \*]transitions idx_state_Flip
    
\*]state idx_state_Flip

} \* region_r19 Human


fair+ process (region_r30 \in {idx_region_r30}) \* Switch
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_BothOff; 
    finalState = idx_Unknown; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r30: currentState[self] := initialState;

\* state idx_state_BothOff[

entry_BothOff: skip;    
    currentState[self] := newState;
    

body_BothOff: skip;
loop_BothOff: skip;
progress_BothOff: skip;    
    if ( noChannel = FALSE ) { 
        L7:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };
    
    
    \* transitions idx_state_BothOff[ 
    L8:
    either {    
        
        \*     (F:'';L:32;C:1) BothOff --> WallOff LampSwitch[]/ (t32)
        await (evtRecv = idx_event_LampSwitch);
        visitedTransitions["t32"] := TRUE;
        
        newState := idx_state_WallOff; 
        goto entry_WallOff;
        
    } or {    
        
        \*     (F:'';L:35;C:1) BothOff --> LampOff WallSwitch[]/ (t35)
        await (evtRecv = idx_event_WallSwitch);
        visitedTransitions["t35"] := TRUE;
        
        newState := idx_state_LampOff; 
        goto entry_LampOff;
        
    }; \* either
    \*]transitions idx_state_BothOff
    
\*]state idx_state_BothOff


\* state idx_state_LampOff[

entry_LampOff: skip;    
    currentState[self] := newState;
    

body_LampOff: skip;
progress_LampOff: skip;    
    if ( noChannel = FALSE ) { 
        L9:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };
    
    
    \* transitions idx_state_LampOff[ 
    L10:
    either {    
        
        \*     (F:'';L:36;C:1) LampOff --> BothOff WallSwitch[]/ (t36)
        await (evtRecv = idx_event_WallSwitch);
        visitedTransitions["t36"] := TRUE;
        
        newState := idx_state_BothOff; 
        goto entry_BothOff;
        
    } or {    
        
        \*     (F:'';L:43;C:1) LampOff --> On LampSwitch[]/ (t43)
        await (evtRecv = idx_event_LampSwitch);
        visitedTransitions["t43"] := TRUE;
        
        newState := idx_state_On; 
        goto entry_On;
        
    }; \* either
    \*]transitions idx_state_LampOff
    
\*]state idx_state_LampOff


\* state idx_state_On[

entry_On: skip;    
    currentState[self] := newState;
    

body_On: skip;
progress_On: skip;    
    if ( noChannel = FALSE ) { 
        L11:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };
    
    
    \* transitions idx_state_On[ 
    L12:
    either {    
        
        \*     (F:'';L:40;C:1) On --> WallOff LampSwitch[]/ (t40)
        await (evtRecv = idx_event_LampSwitch);
        visitedTransitions["t40"] := TRUE;
        
        newState := idx_state_WallOff; 
        goto entry_WallOff;
        
    } or {    
        
        \*     (F:'';L:46;C:1) On --> LampOff WallSwitch[]/ (t46)
        await (evtRecv = idx_event_WallSwitch);
        visitedTransitions["t46"] := TRUE;
        
        newState := idx_state_LampOff; 
        goto entry_LampOff;
        
    }; \* either
    \*]transitions idx_state_On
    
\*]state idx_state_On


\* state idx_state_WallOff[

entry_WallOff: skip;    
    currentState[self] := newState;
    

body_WallOff: skip;
progress_WallOff: skip;    
    if ( noChannel = FALSE ) { 
        L13:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };
    
    
    \* transitions idx_state_WallOff[ 
    L14:
    either {    
        
        \*     (F:'';L:33;C:1) WallOff --> BothOff LampSwitch[]/ (t33)
        await (evtRecv = idx_event_LampSwitch);
        visitedTransitions["t33"] := TRUE;
        
        newState := idx_state_BothOff; 
        goto entry_BothOff;
        
    } or {    
        
        \*     (F:'';L:39;C:1) WallOff --> On WallSwitch[]/ (t39)
        await (evtRecv = idx_event_WallSwitch);
        visitedTransitions["t39"] := TRUE;
        
        newState := idx_state_On; 
        goto entry_On;
        
    }; \* either
    \*]transitions idx_state_WallOff
    
\*]state idx_state_WallOff

} \* region_r30 Switch


} \* algorithm switch

**********************************************************************)
\* BEGIN TRANSLATION (chksum(pcal) = "2ca40dc0" /\ chksum(tla) = "aed41d81")
\* Process variable evtRecv of process region_r17 at line 126 col 5 changed to evtRecv_
\* Process variable initialState of process region_r17 at line 127 col 5 changed to initialState_
\* Process variable finalState of process region_r17 at line 128 col 5 changed to finalState_
\* Process variable newState of process region_r17 at line 129 col 5 changed to newState_
\* Process variable noChannel of process region_r17 at line 130 col 5 changed to noChannel_
\* Process variable evtRecv of process region_r19 at line 174 col 5 changed to evtRecv_r
\* Process variable initialState of process region_r19 at line 175 col 5 changed to initialState_r
\* Process variable finalState of process region_r19 at line 176 col 5 changed to finalState_r
\* Process variable newState of process region_r19 at line 177 col 5 changed to newState_r
\* Process variable noChannel of process region_r19 at line 178 col 5 changed to noChannel_r
VARIABLES procs, channels, currentState, stateTransitions, visitedTransitions, 
          maxUmlEvents, pc

(* define statement *)
MaxEventsReached ==
    /\ [](maxUmlEvents < 0)

AllTransitionsVisited ==
    /\ <>(\A t \in DOMAIN visitedTransitions : visitedTransitions[t] = TRUE)

UmlInvariants ==
    /\ [](TRUE)

VARIABLES evtRecv_, initialState_, finalState_, newState_, noChannel_, 
          evtRecv_r, initialState_r, finalState_r, newState_r, noChannel_r, 
          evtRecv, initialState, finalState, newState, noChannel

vars == << procs, channels, currentState, stateTransitions, 
           visitedTransitions, maxUmlEvents, pc, evtRecv_, initialState_, 
           finalState_, newState_, noChannel_, evtRecv_r, initialState_r, 
           finalState_r, newState_r, noChannel_r, evtRecv, initialState, 
           finalState, newState, noChannel >>

ProcSet == ({idx_region_r17}) \cup ({idx_region_r19}) \cup ({idx_region_r30})

Init == (* Global variables *)
        /\ procs = { idx_region_r17, idx_region_r19, idx_region_r30 }
        /\ channels = [p \in procs |-> <<>>]
        /\ currentState = [p \in procs |-> idx_Unknown]
        /\ stateTransitions = { "t21", "t22", "t32", "t35", "t36", "t43", "t40", "t46", "t33", "t39" }
        /\ visitedTransitions = [t \in stateTransitions |-> FALSE]
        /\ maxUmlEvents = -20
        (* Process region_r17 *)
        /\ evtRecv_ = [self \in {idx_region_r17} |-> idx_Unknown]
        /\ initialState_ = [self \in {idx_region_r17} |-> idx_Unknown]
        /\ finalState_ = [self \in {idx_region_r17} |-> idx_Unknown]
        /\ newState_ = [self \in {idx_region_r17} |-> initialState_[self]]
        /\ noChannel_ = [self \in {idx_region_r17} |-> FALSE]
        (* Process region_r19 *)
        /\ evtRecv_r = [self \in {idx_region_r19} |-> idx_Unknown]
        /\ initialState_r = [self \in {idx_region_r19} |-> idx_state_Flip]
        /\ finalState_r = [self \in {idx_region_r19} |-> idx_Unknown]
        /\ newState_r = [self \in {idx_region_r19} |-> initialState_r[self]]
        /\ noChannel_r = [self \in {idx_region_r19} |-> FALSE]
        (* Process region_r30 *)
        /\ evtRecv = [self \in {idx_region_r30} |-> idx_Unknown]
        /\ initialState = [self \in {idx_region_r30} |-> idx_state_BothOff]
        /\ finalState = [self \in {idx_region_r30} |-> idx_Unknown]
        /\ newState = [self \in {idx_region_r30} |-> initialState[self]]
        /\ noChannel = [self \in {idx_region_r30} |-> FALSE]
        /\ pc = [self \in ProcSet |-> CASE self \in {idx_region_r17} -> "proc_body_idx_region_r17"
                                        [] self \in {idx_region_r19} -> "proc_body_idx_region_r19"
                                        [] self \in {idx_region_r30} -> "proc_body_idx_region_r30"]

proc_body_idx_region_r17(self) == /\ pc[self] = "proc_body_idx_region_r17"
                                  /\ currentState' = [currentState EXCEPT ![self] = initialState_[self]]
                                  /\ pc' = [pc EXCEPT ![self] = "entry_Human"]
                                  /\ UNCHANGED << procs, channels, 
                                                  stateTransitions, 
                                                  visitedTransitions, 
                                                  maxUmlEvents, evtRecv_, 
                                                  initialState_, finalState_, 
                                                  newState_, noChannel_, 
                                                  evtRecv_r, initialState_r, 
                                                  finalState_r, newState_r, 
                                                  noChannel_r, evtRecv, 
                                                  initialState, finalState, 
                                                  newState, noChannel >>

entry_Human(self) == /\ pc[self] = "entry_Human"
                     /\ TRUE
                     /\ currentState' = [currentState EXCEPT ![self] = newState_[self]]
                     /\ noChannel_' = [noChannel_ EXCEPT ![self] = TRUE]
                     /\ pc' = [pc EXCEPT ![self] = "body_Human"]
                     /\ UNCHANGED << procs, channels, stateTransitions, 
                                     visitedTransitions, maxUmlEvents, 
                                     evtRecv_, initialState_, finalState_, 
                                     newState_, evtRecv_r, initialState_r, 
                                     finalState_r, newState_r, noChannel_r, 
                                     evtRecv, initialState, finalState, 
                                     newState, noChannel >>

body_Human(self) == /\ pc[self] = "body_Human"
                    /\ TRUE
                    /\ IF noChannel_[self] = FALSE
                          THEN /\ pc' = [pc EXCEPT ![self] = "L1"]
                               /\ UNCHANGED evtRecv_
                          ELSE /\ evtRecv_' = [evtRecv_ EXCEPT ![self] = idx_event_NullEvent]
                               /\ pc' = [pc EXCEPT ![self] = "entry_Switch"]
                    /\ UNCHANGED << procs, channels, currentState, 
                                    stateTransitions, visitedTransitions, 
                                    maxUmlEvents, initialState_, finalState_, 
                                    newState_, noChannel_, evtRecv_r, 
                                    initialState_r, finalState_r, newState_r, 
                                    noChannel_r, evtRecv, initialState, 
                                    finalState, newState, noChannel >>

L1(self) == /\ pc[self] = "L1"
            /\ Len(channels[self]) > 0
            /\ evtRecv_' = [evtRecv_ EXCEPT ![self] = Head(channels[self])]
            /\ PrintT(<<"P:", self, (currentState[self]), "<-i", evtRecv_'[self]>>)
            /\ channels' = [channels EXCEPT ![self] = Tail(@)]
            /\ pc' = [pc EXCEPT ![self] = "entry_Switch"]
            /\ UNCHANGED << procs, currentState, stateTransitions, 
                            visitedTransitions, maxUmlEvents, initialState_, 
                            finalState_, newState_, noChannel_, evtRecv_r, 
                            initialState_r, finalState_r, newState_r, 
                            noChannel_r, evtRecv, initialState, finalState, 
                            newState, noChannel >>

entry_Switch(self) == /\ pc[self] = "entry_Switch"
                      /\ TRUE
                      /\ currentState' = [currentState EXCEPT ![self] = newState_[self]]
                      /\ noChannel_' = [noChannel_ EXCEPT ![self] = TRUE]
                      /\ pc' = [pc EXCEPT ![self] = "body_Switch"]
                      /\ UNCHANGED << procs, channels, stateTransitions, 
                                      visitedTransitions, maxUmlEvents, 
                                      evtRecv_, initialState_, finalState_, 
                                      newState_, evtRecv_r, initialState_r, 
                                      finalState_r, newState_r, noChannel_r, 
                                      evtRecv, initialState, finalState, 
                                      newState, noChannel >>

body_Switch(self) == /\ pc[self] = "body_Switch"
                     /\ TRUE
                     /\ IF noChannel_[self] = FALSE
                           THEN /\ pc' = [pc EXCEPT ![self] = "L2"]
                                /\ UNCHANGED evtRecv_
                           ELSE /\ evtRecv_' = [evtRecv_ EXCEPT ![self] = idx_event_NullEvent]
                                /\ pc' = [pc EXCEPT ![self] = "Done"]
                     /\ UNCHANGED << procs, channels, currentState, 
                                     stateTransitions, visitedTransitions, 
                                     maxUmlEvents, initialState_, finalState_, 
                                     newState_, noChannel_, evtRecv_r, 
                                     initialState_r, finalState_r, newState_r, 
                                     noChannel_r, evtRecv, initialState, 
                                     finalState, newState, noChannel >>

L2(self) == /\ pc[self] = "L2"
            /\ Len(channels[self]) > 0
            /\ evtRecv_' = [evtRecv_ EXCEPT ![self] = Head(channels[self])]
            /\ PrintT(<<"P:", self, (currentState[self]), "<-i", evtRecv_'[self]>>)
            /\ channels' = [channels EXCEPT ![self] = Tail(@)]
            /\ pc' = [pc EXCEPT ![self] = "Done"]
            /\ UNCHANGED << procs, currentState, stateTransitions, 
                            visitedTransitions, maxUmlEvents, initialState_, 
                            finalState_, newState_, noChannel_, evtRecv_r, 
                            initialState_r, finalState_r, newState_r, 
                            noChannel_r, evtRecv, initialState, finalState, 
                            newState, noChannel >>

region_r17(self) == proc_body_idx_region_r17(self) \/ entry_Human(self)
                       \/ body_Human(self) \/ L1(self)
                       \/ entry_Switch(self) \/ body_Switch(self)
                       \/ L2(self)

proc_body_idx_region_r19(self) == /\ pc[self] = "proc_body_idx_region_r19"
                                  /\ currentState' = [currentState EXCEPT ![self] = initialState_r[self]]
                                  /\ pc' = [pc EXCEPT ![self] = "entry_Flip"]
                                  /\ UNCHANGED << procs, channels, 
                                                  stateTransitions, 
                                                  visitedTransitions, 
                                                  maxUmlEvents, evtRecv_, 
                                                  initialState_, finalState_, 
                                                  newState_, noChannel_, 
                                                  evtRecv_r, initialState_r, 
                                                  finalState_r, newState_r, 
                                                  noChannel_r, evtRecv, 
                                                  initialState, finalState, 
                                                  newState, noChannel >>

entry_Flip(self) == /\ pc[self] = "entry_Flip"
                    /\ TRUE
                    /\ currentState' = [currentState EXCEPT ![self] = newState_r[self]]
                    /\ noChannel_r' = [noChannel_r EXCEPT ![self] = TRUE]
                    /\ pc' = [pc EXCEPT ![self] = "body_Flip"]
                    /\ UNCHANGED << procs, channels, stateTransitions, 
                                    visitedTransitions, maxUmlEvents, evtRecv_, 
                                    initialState_, finalState_, newState_, 
                                    noChannel_, evtRecv_r, initialState_r, 
                                    finalState_r, newState_r, evtRecv, 
                                    initialState, finalState, newState, 
                                    noChannel >>

body_Flip(self) == /\ pc[self] = "body_Flip"
                   /\ TRUE
                   /\ pc' = [pc EXCEPT ![self] = "loop_Flip"]
                   /\ UNCHANGED << procs, channels, currentState, 
                                   stateTransitions, visitedTransitions, 
                                   maxUmlEvents, evtRecv_, initialState_, 
                                   finalState_, newState_, noChannel_, 
                                   evtRecv_r, initialState_r, finalState_r, 
                                   newState_r, noChannel_r, evtRecv, 
                                   initialState, finalState, newState, 
                                   noChannel >>

loop_Flip(self) == /\ pc[self] = "loop_Flip"
                   /\ TRUE
                   /\ IF noChannel_r[self] = FALSE
                         THEN /\ pc' = [pc EXCEPT ![self] = "L3"]
                              /\ UNCHANGED evtRecv_r
                         ELSE /\ evtRecv_r' = [evtRecv_r EXCEPT ![self] = idx_event_NullEvent]
                              /\ pc' = [pc EXCEPT ![self] = "L4"]
                   /\ UNCHANGED << procs, channels, currentState, 
                                   stateTransitions, visitedTransitions, 
                                   maxUmlEvents, evtRecv_, initialState_, 
                                   finalState_, newState_, noChannel_, 
                                   initialState_r, finalState_r, newState_r, 
                                   noChannel_r, evtRecv, initialState, 
                                   finalState, newState, noChannel >>

L3(self) == /\ pc[self] = "L3"
            /\ Len(channels[self]) > 0
            /\ evtRecv_r' = [evtRecv_r EXCEPT ![self] = Head(channels[self])]
            /\ PrintT(<<"P:", self, (currentState[self]), "<-i", evtRecv_r'[self]>>)
            /\ channels' = [channels EXCEPT ![self] = Tail(@)]
            /\ pc' = [pc EXCEPT ![self] = "L4"]
            /\ UNCHANGED << procs, currentState, stateTransitions, 
                            visitedTransitions, maxUmlEvents, evtRecv_, 
                            initialState_, finalState_, newState_, noChannel_, 
                            initialState_r, finalState_r, newState_r, 
                            noChannel_r, evtRecv, initialState, finalState, 
                            newState, noChannel >>

L4(self) == /\ pc[self] = "L4"
            /\ \/ /\ (evtRecv_r[self] = idx_event_NullEvent)
                  /\ pc' = [pc EXCEPT ![self] = "L5"]
               \/ /\ (evtRecv_r[self] = idx_event_NullEvent)
                  /\ pc' = [pc EXCEPT ![self] = "L6"]
            /\ UNCHANGED << procs, channels, currentState, stateTransitions, 
                            visitedTransitions, maxUmlEvents, evtRecv_, 
                            initialState_, finalState_, newState_, noChannel_, 
                            evtRecv_r, initialState_r, finalState_r, 
                            newState_r, noChannel_r, evtRecv, initialState, 
                            finalState, newState, noChannel >>

L5(self) == /\ pc[self] = "L5"
            /\ PrintT(<<"P:", idx_state_Flip, "o->", idx_event_LampSwitch, idx_region_r30, " > P:", idx_state_Switch>>)
            /\ channels' = [channels EXCEPT ![idx_region_r30] = Append(@, idx_event_LampSwitch)]
            /\ maxUmlEvents' = maxUmlEvents + 1
            /\ visitedTransitions' = [visitedTransitions EXCEPT !["t21"] = TRUE]
            /\ newState_r' = [newState_r EXCEPT ![self] = idx_state_Flip]
            /\ pc' = [pc EXCEPT ![self] = "body_Flip"]
            /\ UNCHANGED << procs, currentState, stateTransitions, evtRecv_, 
                            initialState_, finalState_, newState_, noChannel_, 
                            evtRecv_r, initialState_r, finalState_r, 
                            noChannel_r, evtRecv, initialState, finalState, 
                            newState, noChannel >>

L6(self) == /\ pc[self] = "L6"
            /\ PrintT(<<"P:", idx_state_Flip, "o->", idx_event_WallSwitch, idx_region_r30, " > P:", idx_state_Switch>>)
            /\ channels' = [channels EXCEPT ![idx_region_r30] = Append(@, idx_event_WallSwitch)]
            /\ maxUmlEvents' = maxUmlEvents + 1
            /\ visitedTransitions' = [visitedTransitions EXCEPT !["t22"] = TRUE]
            /\ newState_r' = [newState_r EXCEPT ![self] = idx_state_Flip]
            /\ pc' = [pc EXCEPT ![self] = "body_Flip"]
            /\ UNCHANGED << procs, currentState, stateTransitions, evtRecv_, 
                            initialState_, finalState_, newState_, noChannel_, 
                            evtRecv_r, initialState_r, finalState_r, 
                            noChannel_r, evtRecv, initialState, finalState, 
                            newState, noChannel >>

region_r19(self) == proc_body_idx_region_r19(self) \/ entry_Flip(self)
                       \/ body_Flip(self) \/ loop_Flip(self) \/ L3(self)
                       \/ L4(self) \/ L5(self) \/ L6(self)

proc_body_idx_region_r30(self) == /\ pc[self] = "proc_body_idx_region_r30"
                                  /\ currentState' = [currentState EXCEPT ![self] = initialState[self]]
                                  /\ pc' = [pc EXCEPT ![self] = "entry_BothOff"]
                                  /\ UNCHANGED << procs, channels, 
                                                  stateTransitions, 
                                                  visitedTransitions, 
                                                  maxUmlEvents, evtRecv_, 
                                                  initialState_, finalState_, 
                                                  newState_, noChannel_, 
                                                  evtRecv_r, initialState_r, 
                                                  finalState_r, newState_r, 
                                                  noChannel_r, evtRecv, 
                                                  initialState, finalState, 
                                                  newState, noChannel >>

entry_BothOff(self) == /\ pc[self] = "entry_BothOff"
                       /\ TRUE
                       /\ currentState' = [currentState EXCEPT ![self] = newState[self]]
                       /\ pc' = [pc EXCEPT ![self] = "body_BothOff"]
                       /\ UNCHANGED << procs, channels, stateTransitions, 
                                       visitedTransitions, maxUmlEvents, 
                                       evtRecv_, initialState_, finalState_, 
                                       newState_, noChannel_, evtRecv_r, 
                                       initialState_r, finalState_r, 
                                       newState_r, noChannel_r, evtRecv, 
                                       initialState, finalState, newState, 
                                       noChannel >>

body_BothOff(self) == /\ pc[self] = "body_BothOff"
                      /\ TRUE
                      /\ pc' = [pc EXCEPT ![self] = "loop_BothOff"]
                      /\ UNCHANGED << procs, channels, currentState, 
                                      stateTransitions, visitedTransitions, 
                                      maxUmlEvents, evtRecv_, initialState_, 
                                      finalState_, newState_, noChannel_, 
                                      evtRecv_r, initialState_r, finalState_r, 
                                      newState_r, noChannel_r, evtRecv, 
                                      initialState, finalState, newState, 
                                      noChannel >>

loop_BothOff(self) == /\ pc[self] = "loop_BothOff"
                      /\ TRUE
                      /\ pc' = [pc EXCEPT ![self] = "progress_BothOff"]
                      /\ UNCHANGED << procs, channels, currentState, 
                                      stateTransitions, visitedTransitions, 
                                      maxUmlEvents, evtRecv_, initialState_, 
                                      finalState_, newState_, noChannel_, 
                                      evtRecv_r, initialState_r, finalState_r, 
                                      newState_r, noChannel_r, evtRecv, 
                                      initialState, finalState, newState, 
                                      noChannel >>

progress_BothOff(self) == /\ pc[self] = "progress_BothOff"
                          /\ TRUE
                          /\ IF noChannel[self] = FALSE
                                THEN /\ pc' = [pc EXCEPT ![self] = "L7"]
                                     /\ UNCHANGED evtRecv
                                ELSE /\ evtRecv' = [evtRecv EXCEPT ![self] = idx_event_NullEvent]
                                     /\ pc' = [pc EXCEPT ![self] = "L8"]
                          /\ UNCHANGED << procs, channels, currentState, 
                                          stateTransitions, visitedTransitions, 
                                          maxUmlEvents, evtRecv_, 
                                          initialState_, finalState_, 
                                          newState_, noChannel_, evtRecv_r, 
                                          initialState_r, finalState_r, 
                                          newState_r, noChannel_r, 
                                          initialState, finalState, newState, 
                                          noChannel >>

L7(self) == /\ pc[self] = "L7"
            /\ Len(channels[self]) > 0
            /\ evtRecv' = [evtRecv EXCEPT ![self] = Head(channels[self])]
            /\ PrintT(<<"P:", self, (currentState[self]), "<-i", evtRecv'[self]>>)
            /\ channels' = [channels EXCEPT ![self] = Tail(@)]
            /\ pc' = [pc EXCEPT ![self] = "L8"]
            /\ UNCHANGED << procs, currentState, stateTransitions, 
                            visitedTransitions, maxUmlEvents, evtRecv_, 
                            initialState_, finalState_, newState_, noChannel_, 
                            evtRecv_r, initialState_r, finalState_r, 
                            newState_r, noChannel_r, initialState, finalState, 
                            newState, noChannel >>

L8(self) == /\ pc[self] = "L8"
            /\ \/ /\ (evtRecv[self] = idx_event_LampSwitch)
                  /\ visitedTransitions' = [visitedTransitions EXCEPT !["t32"] = TRUE]
                  /\ newState' = [newState EXCEPT ![self] = idx_state_WallOff]
                  /\ pc' = [pc EXCEPT ![self] = "entry_WallOff"]
               \/ /\ (evtRecv[self] = idx_event_WallSwitch)
                  /\ visitedTransitions' = [visitedTransitions EXCEPT !["t35"] = TRUE]
                  /\ newState' = [newState EXCEPT ![self] = idx_state_LampOff]
                  /\ pc' = [pc EXCEPT ![self] = "entry_LampOff"]
            /\ UNCHANGED << procs, channels, currentState, stateTransitions, 
                            maxUmlEvents, evtRecv_, initialState_, finalState_, 
                            newState_, noChannel_, evtRecv_r, initialState_r, 
                            finalState_r, newState_r, noChannel_r, evtRecv, 
                            initialState, finalState, noChannel >>

entry_LampOff(self) == /\ pc[self] = "entry_LampOff"
                       /\ TRUE
                       /\ currentState' = [currentState EXCEPT ![self] = newState[self]]
                       /\ pc' = [pc EXCEPT ![self] = "body_LampOff"]
                       /\ UNCHANGED << procs, channels, stateTransitions, 
                                       visitedTransitions, maxUmlEvents, 
                                       evtRecv_, initialState_, finalState_, 
                                       newState_, noChannel_, evtRecv_r, 
                                       initialState_r, finalState_r, 
                                       newState_r, noChannel_r, evtRecv, 
                                       initialState, finalState, newState, 
                                       noChannel >>

body_LampOff(self) == /\ pc[self] = "body_LampOff"
                      /\ TRUE
                      /\ pc' = [pc EXCEPT ![self] = "progress_LampOff"]
                      /\ UNCHANGED << procs, channels, currentState, 
                                      stateTransitions, visitedTransitions, 
                                      maxUmlEvents, evtRecv_, initialState_, 
                                      finalState_, newState_, noChannel_, 
                                      evtRecv_r, initialState_r, finalState_r, 
                                      newState_r, noChannel_r, evtRecv, 
                                      initialState, finalState, newState, 
                                      noChannel >>

progress_LampOff(self) == /\ pc[self] = "progress_LampOff"
                          /\ TRUE
                          /\ IF noChannel[self] = FALSE
                                THEN /\ pc' = [pc EXCEPT ![self] = "L9"]
                                     /\ UNCHANGED evtRecv
                                ELSE /\ evtRecv' = [evtRecv EXCEPT ![self] = idx_event_NullEvent]
                                     /\ pc' = [pc EXCEPT ![self] = "L10"]
                          /\ UNCHANGED << procs, channels, currentState, 
                                          stateTransitions, visitedTransitions, 
                                          maxUmlEvents, evtRecv_, 
                                          initialState_, finalState_, 
                                          newState_, noChannel_, evtRecv_r, 
                                          initialState_r, finalState_r, 
                                          newState_r, noChannel_r, 
                                          initialState, finalState, newState, 
                                          noChannel >>

L9(self) == /\ pc[self] = "L9"
            /\ Len(channels[self]) > 0
            /\ evtRecv' = [evtRecv EXCEPT ![self] = Head(channels[self])]
            /\ PrintT(<<"P:", self, (currentState[self]), "<-i", evtRecv'[self]>>)
            /\ channels' = [channels EXCEPT ![self] = Tail(@)]
            /\ pc' = [pc EXCEPT ![self] = "L10"]
            /\ UNCHANGED << procs, currentState, stateTransitions, 
                            visitedTransitions, maxUmlEvents, evtRecv_, 
                            initialState_, finalState_, newState_, noChannel_, 
                            evtRecv_r, initialState_r, finalState_r, 
                            newState_r, noChannel_r, initialState, finalState, 
                            newState, noChannel >>

L10(self) == /\ pc[self] = "L10"
             /\ \/ /\ (evtRecv[self] = idx_event_WallSwitch)
                   /\ visitedTransitions' = [visitedTransitions EXCEPT !["t36"] = TRUE]
                   /\ newState' = [newState EXCEPT ![self] = idx_state_BothOff]
                   /\ pc' = [pc EXCEPT ![self] = "entry_BothOff"]
                \/ /\ (evtRecv[self] = idx_event_LampSwitch)
                   /\ visitedTransitions' = [visitedTransitions EXCEPT !["t43"] = TRUE]
                   /\ newState' = [newState EXCEPT ![self] = idx_state_On]
                   /\ pc' = [pc EXCEPT ![self] = "entry_On"]
             /\ UNCHANGED << procs, channels, currentState, stateTransitions, 
                             maxUmlEvents, evtRecv_, initialState_, 
                             finalState_, newState_, noChannel_, evtRecv_r, 
                             initialState_r, finalState_r, newState_r, 
                             noChannel_r, evtRecv, initialState, finalState, 
                             noChannel >>

entry_On(self) == /\ pc[self] = "entry_On"
                  /\ TRUE
                  /\ currentState' = [currentState EXCEPT ![self] = newState[self]]
                  /\ pc' = [pc EXCEPT ![self] = "body_On"]
                  /\ UNCHANGED << procs, channels, stateTransitions, 
                                  visitedTransitions, maxUmlEvents, evtRecv_, 
                                  initialState_, finalState_, newState_, 
                                  noChannel_, evtRecv_r, initialState_r, 
                                  finalState_r, newState_r, noChannel_r, 
                                  evtRecv, initialState, finalState, newState, 
                                  noChannel >>

body_On(self) == /\ pc[self] = "body_On"
                 /\ TRUE
                 /\ pc' = [pc EXCEPT ![self] = "progress_On"]
                 /\ UNCHANGED << procs, channels, currentState, 
                                 stateTransitions, visitedTransitions, 
                                 maxUmlEvents, evtRecv_, initialState_, 
                                 finalState_, newState_, noChannel_, evtRecv_r, 
                                 initialState_r, finalState_r, newState_r, 
                                 noChannel_r, evtRecv, initialState, 
                                 finalState, newState, noChannel >>

progress_On(self) == /\ pc[self] = "progress_On"
                     /\ TRUE
                     /\ IF noChannel[self] = FALSE
                           THEN /\ pc' = [pc EXCEPT ![self] = "L11"]
                                /\ UNCHANGED evtRecv
                           ELSE /\ evtRecv' = [evtRecv EXCEPT ![self] = idx_event_NullEvent]
                                /\ pc' = [pc EXCEPT ![self] = "L12"]
                     /\ UNCHANGED << procs, channels, currentState, 
                                     stateTransitions, visitedTransitions, 
                                     maxUmlEvents, evtRecv_, initialState_, 
                                     finalState_, newState_, noChannel_, 
                                     evtRecv_r, initialState_r, finalState_r, 
                                     newState_r, noChannel_r, initialState, 
                                     finalState, newState, noChannel >>

L11(self) == /\ pc[self] = "L11"
             /\ Len(channels[self]) > 0
             /\ evtRecv' = [evtRecv EXCEPT ![self] = Head(channels[self])]
             /\ PrintT(<<"P:", self, (currentState[self]), "<-i", evtRecv'[self]>>)
             /\ channels' = [channels EXCEPT ![self] = Tail(@)]
             /\ pc' = [pc EXCEPT ![self] = "L12"]
             /\ UNCHANGED << procs, currentState, stateTransitions, 
                             visitedTransitions, maxUmlEvents, evtRecv_, 
                             initialState_, finalState_, newState_, noChannel_, 
                             evtRecv_r, initialState_r, finalState_r, 
                             newState_r, noChannel_r, initialState, finalState, 
                             newState, noChannel >>

L12(self) == /\ pc[self] = "L12"
             /\ \/ /\ (evtRecv[self] = idx_event_LampSwitch)
                   /\ visitedTransitions' = [visitedTransitions EXCEPT !["t40"] = TRUE]
                   /\ newState' = [newState EXCEPT ![self] = idx_state_WallOff]
                   /\ pc' = [pc EXCEPT ![self] = "entry_WallOff"]
                \/ /\ (evtRecv[self] = idx_event_WallSwitch)
                   /\ visitedTransitions' = [visitedTransitions EXCEPT !["t46"] = TRUE]
                   /\ newState' = [newState EXCEPT ![self] = idx_state_LampOff]
                   /\ pc' = [pc EXCEPT ![self] = "entry_LampOff"]
             /\ UNCHANGED << procs, channels, currentState, stateTransitions, 
                             maxUmlEvents, evtRecv_, initialState_, 
                             finalState_, newState_, noChannel_, evtRecv_r, 
                             initialState_r, finalState_r, newState_r, 
                             noChannel_r, evtRecv, initialState, finalState, 
                             noChannel >>

entry_WallOff(self) == /\ pc[self] = "entry_WallOff"
                       /\ TRUE
                       /\ currentState' = [currentState EXCEPT ![self] = newState[self]]
                       /\ pc' = [pc EXCEPT ![self] = "body_WallOff"]
                       /\ UNCHANGED << procs, channels, stateTransitions, 
                                       visitedTransitions, maxUmlEvents, 
                                       evtRecv_, initialState_, finalState_, 
                                       newState_, noChannel_, evtRecv_r, 
                                       initialState_r, finalState_r, 
                                       newState_r, noChannel_r, evtRecv, 
                                       initialState, finalState, newState, 
                                       noChannel >>

body_WallOff(self) == /\ pc[self] = "body_WallOff"
                      /\ TRUE
                      /\ pc' = [pc EXCEPT ![self] = "progress_WallOff"]
                      /\ UNCHANGED << procs, channels, currentState, 
                                      stateTransitions, visitedTransitions, 
                                      maxUmlEvents, evtRecv_, initialState_, 
                                      finalState_, newState_, noChannel_, 
                                      evtRecv_r, initialState_r, finalState_r, 
                                      newState_r, noChannel_r, evtRecv, 
                                      initialState, finalState, newState, 
                                      noChannel >>

progress_WallOff(self) == /\ pc[self] = "progress_WallOff"
                          /\ TRUE
                          /\ IF noChannel[self] = FALSE
                                THEN /\ pc' = [pc EXCEPT ![self] = "L13"]
                                     /\ UNCHANGED evtRecv
                                ELSE /\ evtRecv' = [evtRecv EXCEPT ![self] = idx_event_NullEvent]
                                     /\ pc' = [pc EXCEPT ![self] = "L14"]
                          /\ UNCHANGED << procs, channels, currentState, 
                                          stateTransitions, visitedTransitions, 
                                          maxUmlEvents, evtRecv_, 
                                          initialState_, finalState_, 
                                          newState_, noChannel_, evtRecv_r, 
                                          initialState_r, finalState_r, 
                                          newState_r, noChannel_r, 
                                          initialState, finalState, newState, 
                                          noChannel >>

L13(self) == /\ pc[self] = "L13"
             /\ Len(channels[self]) > 0
             /\ evtRecv' = [evtRecv EXCEPT ![self] = Head(channels[self])]
             /\ PrintT(<<"P:", self, (currentState[self]), "<-i", evtRecv'[self]>>)
             /\ channels' = [channels EXCEPT ![self] = Tail(@)]
             /\ pc' = [pc EXCEPT ![self] = "L14"]
             /\ UNCHANGED << procs, currentState, stateTransitions, 
                             visitedTransitions, maxUmlEvents, evtRecv_, 
                             initialState_, finalState_, newState_, noChannel_, 
                             evtRecv_r, initialState_r, finalState_r, 
                             newState_r, noChannel_r, initialState, finalState, 
                             newState, noChannel >>

L14(self) == /\ pc[self] = "L14"
             /\ \/ /\ (evtRecv[self] = idx_event_LampSwitch)
                   /\ visitedTransitions' = [visitedTransitions EXCEPT !["t33"] = TRUE]
                   /\ newState' = [newState EXCEPT ![self] = idx_state_BothOff]
                   /\ pc' = [pc EXCEPT ![self] = "entry_BothOff"]
                \/ /\ (evtRecv[self] = idx_event_WallSwitch)
                   /\ visitedTransitions' = [visitedTransitions EXCEPT !["t39"] = TRUE]
                   /\ newState' = [newState EXCEPT ![self] = idx_state_On]
                   /\ pc' = [pc EXCEPT ![self] = "entry_On"]
             /\ UNCHANGED << procs, channels, currentState, stateTransitions, 
                             maxUmlEvents, evtRecv_, initialState_, 
                             finalState_, newState_, noChannel_, evtRecv_r, 
                             initialState_r, finalState_r, newState_r, 
                             noChannel_r, evtRecv, initialState, finalState, 
                             noChannel >>

region_r30(self) == proc_body_idx_region_r30(self) \/ entry_BothOff(self)
                       \/ body_BothOff(self) \/ loop_BothOff(self)
                       \/ progress_BothOff(self) \/ L7(self) \/ L8(self)
                       \/ entry_LampOff(self) \/ body_LampOff(self)
                       \/ progress_LampOff(self) \/ L9(self) \/ L10(self)
                       \/ entry_On(self) \/ body_On(self)
                       \/ progress_On(self) \/ L11(self) \/ L12(self)
                       \/ entry_WallOff(self) \/ body_WallOff(self)
                       \/ progress_WallOff(self) \/ L13(self) \/ L14(self)

(* Allow infinite stuttering to prevent deadlock on termination. *)
Terminating == /\ \A self \in ProcSet: pc[self] = "Done"
               /\ UNCHANGED vars

Next == (\E self \in {idx_region_r17}: region_r17(self))
           \/ (\E self \in {idx_region_r19}: region_r19(self))
           \/ (\E self \in {idx_region_r30}: region_r30(self))
           \/ Terminating

Spec == /\ Init /\ [][Next]_vars
        /\ \A self \in {idx_region_r17} : SF_vars(region_r17(self))
        /\ \A self \in {idx_region_r19} : SF_vars(region_r19(self))
        /\ \A self \in {idx_region_r30} : SF_vars(region_r30(self))

Termination == <>(\A self \in ProcSet: pc[self] = "Done")

\* END TRANSLATION 



\* Weakly fair scheduling 
(* PlusCal options (wf) *) 


=======================================================================
