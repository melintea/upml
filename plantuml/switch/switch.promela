/*
./upml --in ../plantuml/switch/switch.plantuml --backend spin --out ../plantuml/switch/switch.promela 
*/
/*
   Generated by UPML v0.05
   Thu Dec 12 12:02:23 2024


    (F:'';L:1;C:1)
    machine switch {
        (F:'';L:17;C:1)
        -- r17 {
            (F:'';L:17;C:1)
            state Human final:0;initial:0 {
                (F:'';L:19;C:1)
                -- r19 {
                    (F:'';L:0;C:0)
                    state Flip final:0;initial:1 {
                        (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)
                        (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)
                        noInboundEvents,
                    }
                }
            }
            (F:'';L:28;C:1)
            state Switch final:0;initial:0 {
                (F:'';L:30;C:1)
                -- r30 {
                    (F:'';L:0;C:0)
                    state BothOff final:0;initial:1 {
                        (F:'';L:32;C:1) BothOff --> WallOff LampSwitch[]/ (t32)
                        (F:'';L:35;C:1) BothOff --> LampOff WallSwitch[]/ (t35)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state LampOff final:0;initial:0 {
                        (F:'';L:36;C:1) LampOff --> BothOff WallSwitch[]/ (t36)
                        (F:'';L:43;C:1) LampOff --> On LampSwitch[]/ (t43)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state On final:0;initial:0 {
                        (F:'';L:40;C:1) On --> WallOff LampSwitch[]/ (t40)
                        (F:'';L:46;C:1) On --> LampOff WallSwitch[]/ (t46)
                        progressTag,
                    }
                    (F:'';L:0;C:0)
                    state WallOff final:0;initial:0 {
                        (F:'';L:33;C:1) WallOff --> BothOff LampSwitch[]/ (t33)
                        (F:'';L:39;C:1) WallOff --> On WallSwitch[]/ (t39)
                        progressTag,
                    }
                }
            }
        }
    } switch

*/


#define idx_unknown -1

#define idx_state_BothOff 0
#define idx_state_Flip 1
#define idx_state_Human 2
#define idx_state_LampOff 3
#define idx_state_On 4
#define idx_state_Switch 5
#define idx_state_WallOff 6

#define idx_region_r17 0
#define idx_region_r19 1
#define idx_region_r30 2

mtype = { event_LampSwitch, event_NullEvent, event_WallSwitch, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[3] = [3] of {event};

inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_r17() // switch
{
    local short myIdx = idx_region_r17;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_unknown; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_Human[*/

entry_Human:
    currentState = newState;
    noChannel = true;


body_Human:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r17 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Human*/


/* state idx_state_Switch[*/

entry_Switch:
    currentState = newState;
    noChannel = true;


body_Switch:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r17 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Switch*/

} // region_r17 switch


proctype region_r19() // Human
{
    local short myIdx = idx_region_r19;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_Flip; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_Flip[*/

entry_Flip:
    currentState = newState;
    noChannel = true;


body_Flip:
loop_Flip:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r19 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_Flip[*/
    if

        //    (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)
        :: (evtRecv.evId == event_NullEvent) -> send_event(idx_region_r30, event_LampSwitch, idx_state_Flip, idx_state_Switch); 

            newState = idx_state_Flip; 
            goto body_Flip;

        //    (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)
        :: (evtRecv.evId == event_NullEvent) -> send_event(idx_region_r30, event_WallSwitch, idx_state_Flip, idx_state_Switch); 

            newState = idx_state_Flip; 
            goto body_Flip;

    fi
    /*]transitions idx_state_Flip*/

/*]state idx_state_Flip*/

} // region_r19 Human


proctype region_r30() // Switch
{
    local short myIdx = idx_region_r30;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_BothOff; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_BothOff[*/

entry_BothOff:
    currentState = newState;


body_BothOff:
loop_BothOff:
progress_BothOff:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BothOff[*/
    if

        //    (F:'';L:32;C:1) BothOff --> WallOff LampSwitch[]/ (t32)
        :: (evtRecv.evId == event_LampSwitch) -> 
            newState = idx_state_WallOff; 
            goto entry_WallOff;

        //    (F:'';L:35;C:1) BothOff --> LampOff WallSwitch[]/ (t35)
        :: (evtRecv.evId == event_WallSwitch) -> 
            newState = idx_state_LampOff; 
            goto entry_LampOff;

    fi
    /*]transitions idx_state_BothOff*/

/*]state idx_state_BothOff*/


/* state idx_state_LampOff[*/

entry_LampOff:
    currentState = newState;


body_LampOff:
progress_LampOff:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_LampOff[*/
    if

        //    (F:'';L:36;C:1) LampOff --> BothOff WallSwitch[]/ (t36)
        :: (evtRecv.evId == event_WallSwitch) -> 
            newState = idx_state_BothOff; 
            goto entry_BothOff;

        //    (F:'';L:43;C:1) LampOff --> On LampSwitch[]/ (t43)
        :: (evtRecv.evId == event_LampSwitch) -> 
            newState = idx_state_On; 
            goto entry_On;

    fi
    /*]transitions idx_state_LampOff*/

/*]state idx_state_LampOff*/


/* state idx_state_On[*/

entry_On:
    currentState = newState;


body_On:
progress_On:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_On[*/
    if

        //    (F:'';L:40;C:1) On --> WallOff LampSwitch[]/ (t40)
        :: (evtRecv.evId == event_LampSwitch) -> 
            newState = idx_state_WallOff; 
            goto entry_WallOff;

        //    (F:'';L:46;C:1) On --> LampOff WallSwitch[]/ (t46)
        :: (evtRecv.evId == event_WallSwitch) -> 
            newState = idx_state_LampOff; 
            goto entry_LampOff;

    fi
    /*]transitions idx_state_On*/

/*]state idx_state_On*/


/* state idx_state_WallOff[*/

entry_WallOff:
    currentState = newState;


body_WallOff:
progress_WallOff:
    if
    :: ( noChannel == false ) ->
        myChan?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_WallOff[*/
    if

        //    (F:'';L:33;C:1) WallOff --> BothOff LampSwitch[]/ (t33)
        :: (evtRecv.evId == event_LampSwitch) -> 
            newState = idx_state_BothOff; 
            goto entry_BothOff;

        //    (F:'';L:39;C:1) WallOff --> On WallSwitch[]/ (t39)
        :: (evtRecv.evId == event_WallSwitch) -> 
            newState = idx_state_On; 
            goto entry_On;

    fi
    /*]transitions idx_state_WallOff*/

/*]state idx_state_WallOff*/

} // region_r30 Switch


proctype invariants() {
end_invariants:
progress_invariants:
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement

    od
}


init {
    atomic {
        run region_r17(); 
        run region_r19(); 
        run region_r30(); 
        run invariants(); 
    }
    //(_nr_pr == 1); 
}


// ltl claims: run with spin -ltl xyz or spin -noclaim 


/*UPML end*/

