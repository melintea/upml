/*
./upml --in ../plantuml/switch/switch.plantuml --backend spin --out ../plantuml/switch/switch.promela 
*/
/*
   Generated by UPML v0.01
   Thu Jun 20 13:05:26 2024


    (F:'';L:1;C:1)
    machine m1 {
        (F:'';L:17;C:1)
        -- r17 {
            (F:'';L:17;C:1)
            state Human final:0;initial:0 {
                (F:'';L:19;C:1)
                -- r19 {
                    (F:'';L:0;C:0)
                    state Flip final:0;initial:1 {
                        (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)
                        (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)
                        noInboundEvents,
                    }
                }
            }
            (F:'';L:28;C:1)
            state Switch final:0;initial:0 {
                (F:'';L:30;C:1)
                -- r30 {
                    (F:'';L:0;C:0)
                    state BothOff final:0;initial:1 {
                        (F:'';L:31;C:1) BothOff --> WallOff LampSwitch[]/ (t31)
                        (F:'';L:34;C:1) BothOff --> LampOff WallSwitch[]/ (t34)
                    }
                    (F:'';L:0;C:0)
                    state LampOff final:0;initial:0 {
                        (F:'';L:35;C:1) LampOff --> BothOff WallSwitch[]/ (t35)
                        (F:'';L:40;C:1) LampOff --> On LampSwitch[]/ (t40)
                    }
                    (F:'';L:0;C:0)
                    state On final:0;initial:0 {
                        (F:'';L:38;C:1) On --> WallOff LampSwitch[]/ (t38)
                        (F:'';L:41;C:1) On --> LampOff WallSwitch[]/ (t41)
                    }
                    (F:'';L:0;C:0)
                    state WallOff final:0;initial:0 {
                        (F:'';L:32;C:1) WallOff --> BothOff LampSwitch[]/ (t32)
                        (F:'';L:37;C:1) WallOff --> On WallSwitch[]/ (t37)
                    }
                }
            }
        }
    } m1

*/


#define idx_unknown -1

#define idx_state_BothOff 0
#define idx_state_Flip 1
#define idx_state_Human 2
#define idx_state_LampOff 3
#define idx_state_On 4
#define idx_state_Switch 5
#define idx_state_WallOff 6

#define idx_region_r17 0
#define idx_region_r19 1
#define idx_region_r30 2

mtype = { event_LampSwitch, event_NullEvent, event_WallSwitch, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[3] = [3] of {event};

inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_r17() // m1
{
    local short myIdx = idx_region_r17;
    local event evtRecv; 
    local short initialState = idx_unknown; 
    local short finalState = idx_unknown; 
    local short crtState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_Human[*/

entry_Human:
    crtState = newState;

body_Human:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r17 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Human*/


/* state idx_state_Switch[*/

entry_Switch:
    crtState = newState;

body_Switch:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r17 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


/*]state idx_state_Switch*/

} // region_r17 m1


proctype region_r19() // Human
{
    local short myIdx = idx_region_r19;
    local event evtRecv; 
    local short initialState = idx_state_Flip; 
    local short finalState = idx_unknown; 
    local short crtState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_Flip[*/

entry_Flip:
    crtState = newState;
    noChannel = true;

body_Flip:
loop_Flip:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r19 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_Flip[*/
    if

            //    (F:'';L:21;C:1) Flip --> Flip NullEvent[]/send,event:LampSwitch,to,state:Switch, (t21)

            :: (evtRecv.evId == event_NullEvent) ->  send_event(idx_region_r30, event_LampSwitch, idx_state_Flip, idx_state_Switch); 

            newState = idx_state_Flip; 
            goto body_Flip;

            //    (F:'';L:22;C:1) Flip --> Flip NullEvent[]/send,event:WallSwitch,to,state:Switch, (t22)

            :: (evtRecv.evId == event_NullEvent) ->  send_event(idx_region_r30, event_WallSwitch, idx_state_Flip, idx_state_Switch); 

            newState = idx_state_Flip; 
            goto body_Flip;

    fi
    /*]transitions idx_state_Flip*/

/*]state idx_state_Flip*/

} // region_r19 Human


proctype region_r30() // Switch
{
    local short myIdx = idx_region_r30;
    local event evtRecv; 
    local short initialState = idx_state_BothOff; 
    local short finalState = idx_unknown; 
    local short crtState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_BothOff[*/

entry_BothOff:
    crtState = newState;

body_BothOff:
loop_BothOff:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_BothOff[*/
    if

            //    (F:'';L:31;C:1) BothOff --> WallOff LampSwitch[]/ (t31)

            :: (evtRecv.evId == event_LampSwitch) -> 
            newState = idx_state_WallOff; 
            goto entry_WallOff;

            //    (F:'';L:34;C:1) BothOff --> LampOff WallSwitch[]/ (t34)

            :: (evtRecv.evId == event_WallSwitch) -> 
            newState = idx_state_LampOff; 
            goto entry_LampOff;

    fi
    /*]transitions idx_state_BothOff*/

/*]state idx_state_BothOff*/


/* state idx_state_LampOff[*/

entry_LampOff:
    crtState = newState;

body_LampOff:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_LampOff[*/
    if

            //    (F:'';L:35;C:1) LampOff --> BothOff WallSwitch[]/ (t35)

            :: (evtRecv.evId == event_WallSwitch) -> 
            newState = idx_state_BothOff; 
            goto entry_BothOff;

            //    (F:'';L:40;C:1) LampOff --> On LampSwitch[]/ (t40)

            :: (evtRecv.evId == event_LampSwitch) -> 
            newState = idx_state_On; 
            goto entry_On;

    fi
    /*]transitions idx_state_LampOff*/

/*]state idx_state_LampOff*/


/* state idx_state_On[*/

entry_On:
    crtState = newState;

body_On:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_On[*/
    if

            //    (F:'';L:38;C:1) On --> WallOff LampSwitch[]/ (t38)

            :: (evtRecv.evId == event_LampSwitch) -> 
            newState = idx_state_WallOff; 
            goto entry_WallOff;

            //    (F:'';L:41;C:1) On --> LampOff WallSwitch[]/ (t41)

            :: (evtRecv.evId == event_WallSwitch) -> 
            newState = idx_state_LampOff; 
            goto entry_LampOff;

    fi
    /*]transitions idx_state_On*/

/*]state idx_state_On*/


/* state idx_state_WallOff[*/

entry_WallOff:
    crtState = newState;

body_WallOff:
    if
    :: ( noChannel == false ) ->
        _channels[myIdx]?evtRecv; 
        printf("MSC: > %d region_r30 event %e in state %d\n", myIdx, evtRecv.evId, crtState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi


    /* transitions idx_state_WallOff[*/
    if

            //    (F:'';L:32;C:1) WallOff --> BothOff LampSwitch[]/ (t32)

            :: (evtRecv.evId == event_LampSwitch) -> 
            newState = idx_state_BothOff; 
            goto entry_BothOff;

            //    (F:'';L:37;C:1) WallOff --> On WallSwitch[]/ (t37)

            :: (evtRecv.evId == event_WallSwitch) -> 
            newState = idx_state_On; 
            goto entry_On;

    fi
    /*]transitions idx_state_WallOff*/

/*]state idx_state_WallOff*/

} // region_r30 Switch

init {
    atomic {
        run region_r17(); 
        run region_r19(); 
        run region_r30(); 
    }
}

/*UPML end*/

