/*
/home/amelinte/work/github/upml/src/upml --in /home/amelinte/work/github/upml/plantuml/trace/send.plantuml --backend spin --out ../plantuml/trace/send.promela 
*/
/*
   Generated by UPML v0.08
   Tue Apr  8 10:50:49 2025


    (F:'';L:1;C:1)
    machine send {
        (F:'';L:10;C:1)
        -- r10 _ownedByState:m1 {
            (F:'';L:0;C:0)
            state Prod final:1;initial:1;_superState:m1;_ownedByRegion:r10 {
                (F:'';L:12;C:1) Prod:entry: send,event:E1,to,state:Cons,;,send,event:E2,to,state:Cons,;, (a12)
                (F:'';L:13;C:1) Prod:chanltl: _channels,[,state:Cons,],!,event:E1,;,_channels,[,state:Cons,],!,event:E2,;, (a13)
            } Prod
        } r10
        (F:'';L:3;C:1)
        -- r3 _ownedByState:m1 {
            (F:'';L:0;C:0)
            state Cons final:1;initial:1;_superState:m1;_ownedByRegion:r3 {
                (F:'';L:5;C:1) Cons --> Cons E1[]/ (t5)
                (F:'';L:6;C:1) Cons --> Cons E2[]/ (t6)
            } Cons
        } r3
    } send
    
*/


#define idx_unknown -1

#define idx_state_Cons 0
#define idx_state_Prod 1

#define idx_region_r10 0
#define idx_region_r3 1

mtype = { event_E1, event_E2, event_EnterState, event_ExitState, event_NullEvent, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[2] = [2] of {event}; 


inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_r10() // send
{
    local short myIdx = idx_region_r10;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_Prod; 
    local short finalState = idx_state_Prod; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_Prod[*/

entry_Prod:    
    currentState = newState;
    noChannel = true;
    
    //    (F:'';L:12;C:1) Prod:entry: send,event:E1,to,state:Cons,;,send,event:E2,to,state:Cons,;, (a12)
    send_event(idx_region_r3, event_E1, idx_state_Prod, idx_state_Cons); 
    send_event(idx_region_r3, event_E2, idx_state_Prod, idx_state_Cons); 
    

body_Prod:
loop_Prod:    
    if
    :: ( noChannel == false ) -> end_Prod:
        myChan?evtRecv; 
        printf("MSC: > %d region_r10 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Prod*/

} // region_r10 send


proctype region_r3() // send
{
    local short myIdx = idx_region_r3;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_Cons; 
    local short finalState = idx_state_Cons; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_Cons[*/

entry_Cons:    
    currentState = newState;
    

body_Cons:
loop_Cons:    
    if
    :: ( noChannel == false ) -> end_Cons:
        myChan?evtRecv; 
        printf("MSC: > %d region_r3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_Cons[*/
    if
        
        //    (F:'';L:5;C:1) Cons --> Cons E1[]/ (t5)
        :: (evtRecv.evId == event_E1) -> 
        newState = idx_state_Cons; 
        goto body_Cons;
            
        //    (F:'';L:6;C:1) Cons --> Cons E2[]/ (t6)
        :: (evtRecv.evId == event_E2) -> 
        newState = idx_state_Cons; 
        goto body_Cons;
        
    fi
    /*]transitions idx_state_Cons*/
    
/*]state idx_state_Cons*/

} // region_r3 send


proctype invariants() {
end_invariants:
progress_invariants:    
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement
    
    od
} // invariants


init {
    atomic {
        run region_r10(); 
        run region_r3(); 
        run invariants(); 
    }
    //(_nr_pr == 1); 
} // init


// ltl claims: run with spin -ltl xyz or spin -noclaim 


//    (F:'';L:13;C:1) Prod:chanltl: _channels,[,state:Cons,],!,event:E1,;,_channels,[,state:Cons,],!,event:E2,;, (a13)
trace { do :: _channels [ idx_state_Cons ] ! event_E1 ; _channels [ idx_state_Cons ] ! event_E2 ;  od; }
 



/*UPML end*/

