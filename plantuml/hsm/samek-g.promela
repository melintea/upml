/*
/home/amelinte/work/github/upml/src/upml --in /home/amelinte/work/github/upml/plantuml/hsm/samek-g.plantuml --backend spin-hsm --out ../plantuml/hsm/samek-g.promela 
*/
/*
   Generated by UPML v0.09
   Thu Jun 26 16:50:48 2025


    (F:'';L:1;C:1)
    machine samek-g {
        (F:'';L:13;C:1)
        -- m1INr13 _ownedByState:m1 {
            (F:'';L:14;C:1)
            state SuperSuper final:0;initial:1;_superState:m1;_ownedByRegion:m1INr13 {
                (F:'';L:57;C:1) SuperSuper --> S11 E[]/ (t57)
                (F:'';L:15;C:3) SuperSuper:entry:  (a15)
                (F:'';L:16;C:3) SuperSuper:exit:  (a16)
                (F:'';L:15;C:3)
                -- SuperSuperINr15 _ownedByState:SuperSuper {
                    (F:'';L:35;C:3)
                    state Super1 final:0;initial:0;_superState:SuperSuper;_ownedByRegion:SuperSuperINr15 {
                        (F:'';L:51;C:1) Super1 --> Super2 C[]/ (t51)
                        (F:'';L:55;C:1) Super1 --> SuperSuper D[]/ (t55)
                        (F:'';L:60;C:1) Super1 --> S211 F[]/ (t60)
                        (F:'';L:37;C:7) Super1:entry:  (a37)
                        (F:'';L:38;C:7) Super1:exit:  (a38)
                        (F:'';L:36;C:7)
                        -- Super1INr36 _ownedByState:Super1 {
                            (F:'';L:0;C:0)
                            state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr36 {
                                (F:'';L:54;C:1) S11 --> Super1 D[]/ (t54)
                                (F:'';L:63;C:1) S11 --> S211 G[]/ (t63)
                                (F:'';L:66;C:1) S11 --> SuperSuper H[]/ (t66)
                                (F:'';L:40;C:7) S11:entry:  (a40)
                                (F:'';L:41;C:7) S11:exit:  (a41)
                            } S11
                        } Super1INr36
                    } Super1
                    (F:'';L:19;C:3)
                    state Super2 final:0;initial:1;_superState:SuperSuper;_ownedByRegion:SuperSuperINr15 {
                        (F:'';L:50;C:1) Super2 --> Super1 C[]/ (t50)
                        (F:'';L:59;C:1) Super2 --> S11 F[]/ (t59)
                        (F:'';L:20;C:7) Super2:entry:  (a20)
                        (F:'';L:21;C:7) Super2:exit:  (a21)
                        (F:'';L:20;C:7)
                        -- Super2INr20 _ownedByState:Super2 {
                            (F:'';L:24;C:7)
                            state Super21 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr20 {
                                (F:'';L:46;C:1) Super21 --> Super21 A[]/ (t46)
                                (F:'';L:48;C:1) Super21 --> S211 B[]/ (t48)
                                (F:'';L:62;C:1) Super21 --> S11 G[]/ (t62)
                                (F:'';L:25;C:11) Super21:entry:  (a25)
                                (F:'';L:26;C:11) Super21:exit:  (a26)
                                (F:'';L:27;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a27)
                                (F:'';L:25;C:11)
                                -- Super21INr25 _ownedByState:Super21 {
                                    (F:'';L:0;C:0)
                                    state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr25 {
                                        (F:'';L:53;C:1) S211 --> Super21 D[]/ (t53)
                                        (F:'';L:65;C:1) S211 --> SuperSuper H[]/ (t65)
                                        (F:'';L:30;C:11) S211:entry:  (a30)
                                        (F:'';L:31;C:11) S211:exit:  (a31)
                                    } S211
                                } Super21INr25
                            } Super21
                        } Super2INr20
                    } Super2
                } SuperSuperINr15
            } SuperSuper
        } m1INr13
        (F:'';L:70;C:1)
        -- m1INr70 _ownedByState:m1 {
            (F:'';L:70;C:1)
            state Test final:1;initial:1;_superState:m1;_ownedByRegion:m1INr70 {
                (F:'';L:73;C:1) Test:entry: send,event:G,to,state:SuperSuper, (a73)
                (F:'';L:74;C:1) Test:chanltl: _internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super21,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211,),;,_externalEvents,[,state:SuperSuper,],!,event:G,;,_internalEvents,[,state:SuperSuper,],!,event:ExitState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super1,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;, (a74)
                (F:'';L:83;C:1) Test:ltl: ltlEnd,{,[],(,(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super2,],&&,_currentState,[,state:Super21,],&&,_currentState,[,state:S211,],),->,<>,[],(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super1,],&&,_currentState,[,state:S11,],&&,!,_currentState,[,state:S211,],),),}, (a83)
                (F:'';L:71;C:1)
                -- TestINr71 _ownedByState:Test {
                } TestINr71
            } Test
        } m1INr70
    } samek-g
    
*/


#define idx_unknown 0

#define idx_statusNotProcessed 0
#define idx_statusProcessed 1

#define idx_state_S11 1
#define idx_state_S211 2
#define idx_state_Super1 3
#define idx_state_Super2 4
#define idx_state_Super21 5
#define idx_state_SuperSuper 6
#define idx_state_Test 7
#define numStates 8

bool _currentState[numStates]; 
bool _initialState[numStates]; 

#define initialized (true && _initialState[idx_state_S211] && _initialState[idx_state_Super2] && _initialState[idx_state_Super21] && _initialState[idx_state_SuperSuper] && _initialState[idx_state_Test])

#define idx_region_Super1INr36 1
#define idx_region_Super21INr25 2
#define idx_region_Super2INr20 3
#define idx_region_SuperSuperINr15 4
#define idx_region_TestINr71 5
#define idx_region_m1INr13 6
#define idx_region_m1INr70 7

mtype = { event_A, event_B, event_C, event_D, event_E, event_EnterState, event_ExitState, event_F, event_G, event_H, event_NullEvent, };
typedef event {mtype evId; short toState; short fromState;};
typedef eventStatus {mtype evId; short status;};

int _chanMap[numStates] = {0,0,0,0,0,0,0,1};
chan _externalEvents[2] = [1] of {event};
chan _internalEvents[2] = [2*6] of {event};

chan _eventProcessed[2] = [1] of {eventStatus};

inline send_internal_event(evt, fromState, toState)
{
    assert(nfull(_internalEvents[_chanMap[toState]]));
    _internalEvents[_chanMap[toState]]!evt(toState, fromState);
}

inline send_event(evt, fromState, toState)
{
    (initialized && empty(_internalEvents[_chanMap[toState]]));
    _externalEvents[_chanMap[toState]]!evt(toState, fromState);
    _eventProcessed[_chanMap[toState]]?_(_);
}
            
/*
    (F:'';L:0;C:0)
    state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr25 {
        (F:'';L:53;C:1) S211 --> Super21 D[]/ (t53)
        (F:'';L:65;C:1) S211 --> SuperSuper H[]/ (t65)
        (F:'';L:30;C:11) S211:entry:  (a30)
        (F:'';L:31;C:11) S211:exit:  (a31)
    } S211
*/
proctype S211(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_S211:
    
    _initialState[idx_state_S211] = 1;
    _currentState[idx_state_S211] = true;

body_S211:
loop_S211:    
    end_S211: superChannel?evtRecv;
    printf("MSC: > S211 event %e in state %d\n", evtRecv.evId, idx_state_S211);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S211) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_S211; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_S211 || evtRecv.toState == idx_unknown)) -> 
       goto exit_S211; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_S211[*/
    if
        
        //    (F:'';L:53;C:1) S211 --> Super21 D[]/ (t53)
        :: (evtRecv.evId == event_D) -> 
        // [*]->ExitState:S211->ExitState:Super21->[Super2]->EnterState:Super21->[*]
        send_internal_event(event_ExitState, idx_state_S211, idx_state_Super21);
        send_internal_event(event_EnterState, idx_state_S211, idx_state_Super21);
        eventProcessedChan!event_D(idx_statusProcessed);
        goto body_S211;
            
        //    (F:'';L:65;C:1) S211 --> SuperSuper H[]/ (t65)
        :: (evtRecv.evId == event_H) -> 
        // [*]->ExitState:S211->ExitState:Super21->ExitState:Super2->ExitState:SuperSuper->[m1]->EnterState:SuperSuper->[*]
        send_internal_event(event_ExitState, idx_state_S211, idx_state_SuperSuper);
        send_internal_event(event_EnterState, idx_state_S211, idx_state_SuperSuper);
        eventProcessedChan!event_H(idx_statusProcessed);
        goto body_S211;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_S211;
    fi
    /*]transitions idx_state_S211*/
    
    } // atomic

exit_S211:    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_S211] = false;
} // S211


/*
    (F:'';L:24;C:7)
    state Super21 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr20 {
        (F:'';L:46;C:1) Super21 --> Super21 A[]/ (t46)
        (F:'';L:48;C:1) Super21 --> S211 B[]/ (t48)
        (F:'';L:62;C:1) Super21 --> S11 G[]/ (t62)
        (F:'';L:25;C:11) Super21:entry:  (a25)
        (F:'';L:26;C:11) Super21:exit:  (a26)
        (F:'';L:27;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a27)
        (F:'';L:25;C:11)
        -- Super21INr25 _ownedByState:Super21 {
            (F:'';L:0;C:0)
            state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr25 {
                (F:'';L:53;C:1) S211 --> Super21 D[]/ (t53)
                (F:'';L:65;C:1) S211 --> SuperSuper H[]/ (t65)
                (F:'';L:30;C:11) S211:entry:  (a30)
                (F:'';L:31;C:11) S211:exit:  (a31)
            } S211
        } Super21INr25
    } Super21
*/
proctype Super21(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;
    chan substateChannel_Super21INr25 = [1] of {event};
    chan substateEventProcessedChan = [1] of {eventStatus};

entry_Super21:
    
    _initialState[idx_state_Super21] = 1;
    //    (F:'';L:27;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a27)
    assert((_currentState[idx_state_Super2]&&!_currentState[idx_state_Super1]));
    
    send_internal_event(event_EnterState, idx_state_Super21, idx_state_S211);
    _currentState[idx_state_Super21] = true;

body_Super21:
loop_Super21:    
    end_Super21: superChannel?evtRecv;
    printf("MSC: > Super21 event %e in state %d\n", evtRecv.evId, idx_state_Super21);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super21) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super21; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_Super21 || evtRecv.toState == idx_unknown)) -> 
       goto exit_Super21; 
    
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S211) -> 
       run S211(substateChannel_Super21INr25, substateEventProcessedChan);
       _currentState[idx_state_S211] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super21;
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    eventProcessed.status = idx_unknown;
    substateChannel_Super21INr25!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super21;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_Super21[*/
    if
        
        //    (F:'';L:46;C:1) Super21 --> Super21 A[]/ (t46)
        :: (evtRecv.evId == event_A) -> 
        goto body_Super21;
            
        //    (F:'';L:48;C:1) Super21 --> S211 B[]/ (t48)
        :: (evtRecv.evId == event_B) -> 
        // [*]->ExitState:Super21->[Super2]->EnterState:Super21->EnterState:S211->[*]
        send_internal_event(event_ExitState, idx_state_Super21, idx_state_Super21);
        send_internal_event(event_EnterState, idx_state_Super21, idx_state_Super21);
        send_internal_event(event_EnterState, idx_state_Super21, idx_state_S211);
        eventProcessedChan!event_B(idx_statusProcessed);
        goto body_Super21;
            
        //    (F:'';L:62;C:1) Super21 --> S11 G[]/ (t62)
        :: (evtRecv.evId == event_G) -> 
        // [*]->ExitState:Super21->ExitState:Super2->[SuperSuper]->EnterState:Super1->EnterState:S11->[*]
        send_internal_event(event_ExitState, idx_state_Super21, idx_state_Super2);
        send_internal_event(event_EnterState, idx_state_Super21, idx_state_Super1);
        send_internal_event(event_EnterState, idx_state_Super21, idx_state_S11);
        eventProcessedChan!event_G(idx_statusProcessed);
        goto body_Super21;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_Super21;
    fi
    /*]transitions idx_state_Super21*/
    
    } // atomic

exit_Super21:    
    eventProcessed.status = idx_unknown;
    substateChannel_Super21INr25!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_Super21] = false;
} // Super21


/*
    (F:'';L:19;C:3)
    state Super2 final:0;initial:1;_superState:SuperSuper;_ownedByRegion:SuperSuperINr15 {
        (F:'';L:50;C:1) Super2 --> Super1 C[]/ (t50)
        (F:'';L:59;C:1) Super2 --> S11 F[]/ (t59)
        (F:'';L:20;C:7) Super2:entry:  (a20)
        (F:'';L:21;C:7) Super2:exit:  (a21)
        (F:'';L:20;C:7)
        -- Super2INr20 _ownedByState:Super2 {
            (F:'';L:24;C:7)
            state Super21 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr20 {
                (F:'';L:46;C:1) Super21 --> Super21 A[]/ (t46)
                (F:'';L:48;C:1) Super21 --> S211 B[]/ (t48)
                (F:'';L:62;C:1) Super21 --> S11 G[]/ (t62)
                (F:'';L:25;C:11) Super21:entry:  (a25)
                (F:'';L:26;C:11) Super21:exit:  (a26)
                (F:'';L:27;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a27)
                (F:'';L:25;C:11)
                -- Super21INr25 _ownedByState:Super21 {
                    (F:'';L:0;C:0)
                    state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr25 {
                        (F:'';L:53;C:1) S211 --> Super21 D[]/ (t53)
                        (F:'';L:65;C:1) S211 --> SuperSuper H[]/ (t65)
                        (F:'';L:30;C:11) S211:entry:  (a30)
                        (F:'';L:31;C:11) S211:exit:  (a31)
                    } S211
                } Super21INr25
            } Super21
        } Super2INr20
    } Super2
*/
proctype Super2(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;
    chan substateChannel_Super2INr20 = [1] of {event};
    chan substateEventProcessedChan = [1] of {eventStatus};

entry_Super2:
    
    _initialState[idx_state_Super2] = 1;
    send_internal_event(event_EnterState, idx_state_Super2, idx_state_Super21);
    _currentState[idx_state_Super2] = true;

body_Super2:
loop_Super2:    
    end_Super2: superChannel?evtRecv;
    printf("MSC: > Super2 event %e in state %d\n", evtRecv.evId, idx_state_Super2);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super2) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super2; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_Super2 || evtRecv.toState == idx_unknown)) -> 
       goto exit_Super2; 
    
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super21) -> 
       run Super21(substateChannel_Super2INr20, substateEventProcessedChan);
       _currentState[idx_state_Super21] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super2;
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    eventProcessed.status = idx_unknown;
    substateChannel_Super2INr20!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super2;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_Super2[*/
    if
        
        //    (F:'';L:50;C:1) Super2 --> Super1 C[]/ (t50)
        :: (evtRecv.evId == event_C) -> 
        // [*]->ExitState:Super2->[SuperSuper]->EnterState:Super1->[*]
        send_internal_event(event_ExitState, idx_state_Super2, idx_state_Super2);
        send_internal_event(event_EnterState, idx_state_Super2, idx_state_Super1);
        eventProcessedChan!event_C(idx_statusProcessed);
        goto body_Super2;
            
        //    (F:'';L:59;C:1) Super2 --> S11 F[]/ (t59)
        :: (evtRecv.evId == event_F) -> 
        // [*]->ExitState:Super2->[SuperSuper]->EnterState:Super1->EnterState:S11->[*]
        send_internal_event(event_ExitState, idx_state_Super2, idx_state_Super2);
        send_internal_event(event_EnterState, idx_state_Super2, idx_state_Super1);
        send_internal_event(event_EnterState, idx_state_Super2, idx_state_S11);
        eventProcessedChan!event_F(idx_statusProcessed);
        goto body_Super2;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_Super2;
    fi
    /*]transitions idx_state_Super2*/
    
    } // atomic

exit_Super2:    
    eventProcessed.status = idx_unknown;
    substateChannel_Super2INr20!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_Super2] = false;
} // Super2

    
/*
    (F:'';L:0;C:0)
    state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr36 {
        (F:'';L:54;C:1) S11 --> Super1 D[]/ (t54)
        (F:'';L:63;C:1) S11 --> S211 G[]/ (t63)
        (F:'';L:66;C:1) S11 --> SuperSuper H[]/ (t66)
        (F:'';L:40;C:7) S11:entry:  (a40)
        (F:'';L:41;C:7) S11:exit:  (a41)
    } S11
*/
proctype S11(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_S11:
    
    _initialState[idx_state_S11] = 1;
    _currentState[idx_state_S11] = true;

body_S11:
loop_S11:    
    end_S11: superChannel?evtRecv;
    printf("MSC: > S11 event %e in state %d\n", evtRecv.evId, idx_state_S11);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S11) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_S11; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_S11 || evtRecv.toState == idx_unknown)) -> 
       goto exit_S11; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_S11[*/
    if
        
        //    (F:'';L:54;C:1) S11 --> Super1 D[]/ (t54)
        :: (evtRecv.evId == event_D) -> 
        // [*]->ExitState:S11->ExitState:Super1->[SuperSuper]->EnterState:Super1->[*]
        send_internal_event(event_ExitState, idx_state_S11, idx_state_Super1);
        send_internal_event(event_EnterState, idx_state_S11, idx_state_Super1);
        eventProcessedChan!event_D(idx_statusProcessed);
        goto body_S11;
            
        //    (F:'';L:63;C:1) S11 --> S211 G[]/ (t63)
        :: (evtRecv.evId == event_G) -> 
        // [*]->ExitState:S11->ExitState:Super1->[SuperSuper]->EnterState:Super2->EnterState:Super21->EnterState:S211->[*]
        send_internal_event(event_ExitState, idx_state_S11, idx_state_Super1);
        send_internal_event(event_EnterState, idx_state_S11, idx_state_Super2);
        send_internal_event(event_EnterState, idx_state_S11, idx_state_Super21);
        send_internal_event(event_EnterState, idx_state_S11, idx_state_S211);
        eventProcessedChan!event_G(idx_statusProcessed);
        goto body_S11;
            
        //    (F:'';L:66;C:1) S11 --> SuperSuper H[]/ (t66)
        :: (evtRecv.evId == event_H) -> 
        // [*]->ExitState:S11->ExitState:Super1->ExitState:SuperSuper->[m1]->EnterState:SuperSuper->[*]
        send_internal_event(event_ExitState, idx_state_S11, idx_state_SuperSuper);
        send_internal_event(event_EnterState, idx_state_S11, idx_state_SuperSuper);
        eventProcessedChan!event_H(idx_statusProcessed);
        goto body_S11;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_S11;
    fi
    /*]transitions idx_state_S11*/
    
    } // atomic

exit_S11:    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_S11] = false;
} // S11


/*
    (F:'';L:35;C:3)
    state Super1 final:0;initial:0;_superState:SuperSuper;_ownedByRegion:SuperSuperINr15 {
        (F:'';L:51;C:1) Super1 --> Super2 C[]/ (t51)
        (F:'';L:55;C:1) Super1 --> SuperSuper D[]/ (t55)
        (F:'';L:60;C:1) Super1 --> S211 F[]/ (t60)
        (F:'';L:37;C:7) Super1:entry:  (a37)
        (F:'';L:38;C:7) Super1:exit:  (a38)
        (F:'';L:36;C:7)
        -- Super1INr36 _ownedByState:Super1 {
            (F:'';L:0;C:0)
            state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr36 {
                (F:'';L:54;C:1) S11 --> Super1 D[]/ (t54)
                (F:'';L:63;C:1) S11 --> S211 G[]/ (t63)
                (F:'';L:66;C:1) S11 --> SuperSuper H[]/ (t66)
                (F:'';L:40;C:7) S11:entry:  (a40)
                (F:'';L:41;C:7) S11:exit:  (a41)
            } S11
        } Super1INr36
    } Super1
*/
proctype Super1(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;
    chan substateChannel_Super1INr36 = [1] of {event};
    chan substateEventProcessedChan = [1] of {eventStatus};

entry_Super1:
    
    _initialState[idx_state_Super1] = 0;
    send_internal_event(event_EnterState, idx_state_Super1, idx_state_S11);
    _currentState[idx_state_Super1] = true;

body_Super1:    
    end_Super1: superChannel?evtRecv;
    printf("MSC: > Super1 event %e in state %d\n", evtRecv.evId, idx_state_Super1);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super1) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super1; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_Super1 || evtRecv.toState == idx_unknown)) -> 
       goto exit_Super1; 
    
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S11) -> 
       run S11(substateChannel_Super1INr36, substateEventProcessedChan);
       _currentState[idx_state_S11] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super1;
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    eventProcessed.status = idx_unknown;
    substateChannel_Super1INr36!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super1;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_Super1[*/
    if
        
        //    (F:'';L:51;C:1) Super1 --> Super2 C[]/ (t51)
        :: (evtRecv.evId == event_C) -> 
        // [*]->ExitState:Super1->[SuperSuper]->EnterState:Super2->[*]
        send_internal_event(event_ExitState, idx_state_Super1, idx_state_Super1);
        send_internal_event(event_EnterState, idx_state_Super1, idx_state_Super2);
        eventProcessedChan!event_C(idx_statusProcessed);
        goto body_Super1;
            
        //    (F:'';L:55;C:1) Super1 --> SuperSuper D[]/ (t55)
        :: (evtRecv.evId == event_D) -> 
        // [*]->ExitState:Super1->ExitState:SuperSuper->[m1]->EnterState:SuperSuper->[*]
        send_internal_event(event_ExitState, idx_state_Super1, idx_state_SuperSuper);
        send_internal_event(event_EnterState, idx_state_Super1, idx_state_SuperSuper);
        eventProcessedChan!event_D(idx_statusProcessed);
        goto body_Super1;
            
        //    (F:'';L:60;C:1) Super1 --> S211 F[]/ (t60)
        :: (evtRecv.evId == event_F) -> 
        // [*]->ExitState:Super1->[SuperSuper]->EnterState:Super2->EnterState:Super21->EnterState:S211->[*]
        send_internal_event(event_ExitState, idx_state_Super1, idx_state_Super1);
        send_internal_event(event_EnterState, idx_state_Super1, idx_state_Super2);
        send_internal_event(event_EnterState, idx_state_Super1, idx_state_Super21);
        send_internal_event(event_EnterState, idx_state_Super1, idx_state_S211);
        eventProcessedChan!event_F(idx_statusProcessed);
        goto body_Super1;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_Super1;
    fi
    /*]transitions idx_state_Super1*/
    
    } // atomic

exit_Super1:    
    eventProcessed.status = idx_unknown;
    substateChannel_Super1INr36!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_Super1] = false;
} // Super1


/*
    (F:'';L:14;C:1)
    state SuperSuper final:0;initial:1;_superState:m1;_ownedByRegion:m1INr13 {
        (F:'';L:57;C:1) SuperSuper --> S11 E[]/ (t57)
        (F:'';L:15;C:3) SuperSuper:entry:  (a15)
        (F:'';L:16;C:3) SuperSuper:exit:  (a16)
        (F:'';L:15;C:3)
        -- SuperSuperINr15 _ownedByState:SuperSuper {
            (F:'';L:35;C:3)
            state Super1 final:0;initial:0;_superState:SuperSuper;_ownedByRegion:SuperSuperINr15 {
                (F:'';L:51;C:1) Super1 --> Super2 C[]/ (t51)
                (F:'';L:55;C:1) Super1 --> SuperSuper D[]/ (t55)
                (F:'';L:60;C:1) Super1 --> S211 F[]/ (t60)
                (F:'';L:37;C:7) Super1:entry:  (a37)
                (F:'';L:38;C:7) Super1:exit:  (a38)
                (F:'';L:36;C:7)
                -- Super1INr36 _ownedByState:Super1 {
                    (F:'';L:0;C:0)
                    state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr36 {
                        (F:'';L:54;C:1) S11 --> Super1 D[]/ (t54)
                        (F:'';L:63;C:1) S11 --> S211 G[]/ (t63)
                        (F:'';L:66;C:1) S11 --> SuperSuper H[]/ (t66)
                        (F:'';L:40;C:7) S11:entry:  (a40)
                        (F:'';L:41;C:7) S11:exit:  (a41)
                    } S11
                } Super1INr36
            } Super1
            (F:'';L:19;C:3)
            state Super2 final:0;initial:1;_superState:SuperSuper;_ownedByRegion:SuperSuperINr15 {
                (F:'';L:50;C:1) Super2 --> Super1 C[]/ (t50)
                (F:'';L:59;C:1) Super2 --> S11 F[]/ (t59)
                (F:'';L:20;C:7) Super2:entry:  (a20)
                (F:'';L:21;C:7) Super2:exit:  (a21)
                (F:'';L:20;C:7)
                -- Super2INr20 _ownedByState:Super2 {
                    (F:'';L:24;C:7)
                    state Super21 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr20 {
                        (F:'';L:46;C:1) Super21 --> Super21 A[]/ (t46)
                        (F:'';L:48;C:1) Super21 --> S211 B[]/ (t48)
                        (F:'';L:62;C:1) Super21 --> S11 G[]/ (t62)
                        (F:'';L:25;C:11) Super21:entry:  (a25)
                        (F:'';L:26;C:11) Super21:exit:  (a26)
                        (F:'';L:27;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a27)
                        (F:'';L:25;C:11)
                        -- Super21INr25 _ownedByState:Super21 {
                            (F:'';L:0;C:0)
                            state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr25 {
                                (F:'';L:53;C:1) S211 --> Super21 D[]/ (t53)
                                (F:'';L:65;C:1) S211 --> SuperSuper H[]/ (t65)
                                (F:'';L:30;C:11) S211:entry:  (a30)
                                (F:'';L:31;C:11) S211:exit:  (a31)
                            } S211
                        } Super21INr25
                    } Super21
                } Super2INr20
            } Super2
        } SuperSuperINr15
    } SuperSuper
*/
proctype SuperSuper(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;
    chan substateChannel_SuperSuperINr15 = [1] of {event};
    chan substateEventProcessedChan = [1] of {eventStatus};

entry_SuperSuper:
    
    _initialState[idx_state_SuperSuper] = 1;
    send_internal_event(event_EnterState, idx_state_SuperSuper, idx_state_Super2);
    _currentState[idx_state_SuperSuper] = true;

body_SuperSuper:
loop_SuperSuper:    
    if
    :: nempty(_internalEvents[0]) -> _internalEvents[0]?evtRecv;
    :: initialized && empty(_internalEvents[0])  -> end_SuperSuper: superChannel?evtRecv;
    fi
    printf("MSC: > SuperSuper event %e in state %d\n", evtRecv.evId, idx_state_SuperSuper);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_SuperSuper) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_SuperSuper; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_SuperSuper || evtRecv.toState == idx_unknown)) -> 
       goto exit_SuperSuper; 
    
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super1) -> 
       run Super1(substateChannel_SuperSuperINr15, substateEventProcessedChan);
       _currentState[idx_state_Super1] == true;
       goto body_SuperSuper;
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super2) -> 
       run Super2(substateChannel_SuperSuperINr15, substateEventProcessedChan);
       _currentState[idx_state_Super2] == true;
       goto body_SuperSuper;
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    eventProcessed.status = idx_unknown;
    substateChannel_SuperSuperINr15!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       if
       :: (evtRecv.evId == event_EnterState || evtRecv.evId == event_ExitState) -> 
          skip;
       :: else -> eventProcessedChan!eventProcessed;
       fi
       goto body_SuperSuper;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_SuperSuper[*/
    if
        
        //    (F:'';L:57;C:1) SuperSuper --> S11 E[]/ (t57)
        :: (evtRecv.evId == event_E) -> 
        // [*]->ExitState:SuperSuper->[m1]->EnterState:SuperSuper->EnterState:Super1->EnterState:S11->[*]
        send_internal_event(event_ExitState, idx_state_SuperSuper, idx_state_SuperSuper);
        send_internal_event(event_EnterState, idx_state_SuperSuper, idx_state_SuperSuper);
        send_internal_event(event_EnterState, idx_state_SuperSuper, idx_state_Super1);
        send_internal_event(event_EnterState, idx_state_SuperSuper, idx_state_S11);
        eventProcessedChan!event_E(idx_statusProcessed);
        goto body_SuperSuper;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_SuperSuper;
    fi
    /*]transitions idx_state_SuperSuper*/
    
    } // atomic

exit_SuperSuper:    
    eventProcessed.status = idx_unknown;
    substateChannel_SuperSuperINr15!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    _currentState[idx_state_SuperSuper] = false;
} // SuperSuper

    
/*
    (F:'';L:70;C:1)
    state Test final:1;initial:1;_superState:m1;_ownedByRegion:m1INr70 {
        (F:'';L:73;C:1) Test:entry: send,event:G,to,state:SuperSuper, (a73)
        (F:'';L:74;C:1) Test:chanltl: _internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super21,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211,),;,_externalEvents,[,state:SuperSuper,],!,event:G,;,_internalEvents,[,state:SuperSuper,],!,event:ExitState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super1,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;, (a74)
        (F:'';L:83;C:1) Test:ltl: ltlEnd,{,[],(,(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super2,],&&,_currentState,[,state:Super21,],&&,_currentState,[,state:S211,],),->,<>,[],(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super1,],&&,_currentState,[,state:S11,],&&,!,_currentState,[,state:S211,],),),}, (a83)
        (F:'';L:71;C:1)
        -- TestINr71 _ownedByState:Test {
        } TestINr71
    } Test
*/
proctype Test(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_Test:
    
    _initialState[idx_state_Test] = 1;
    //    (F:'';L:73;C:1) Test:entry: send,event:G,to,state:SuperSuper, (a73)
    send_event(event_G, idx_state_Test, idx_state_SuperSuper); 
    
    _currentState[idx_state_Test] = true;

body_Test:
loop_Test:    
    if
    :: nempty(_internalEvents[1]) -> _internalEvents[1]?evtRecv;
    :: initialized && empty(_internalEvents[1])  -> end_Test: superChannel?evtRecv;
    fi
    printf("MSC: > Test event %e in state %d\n", evtRecv.evId, idx_state_Test);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Test) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Test; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_Test || evtRecv.toState == idx_unknown)) -> 
       goto exit_Test; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
    goto body_Test;

exit_Test:    
    _currentState[idx_state_Test] = false;
} // Test



proctype invariants() {
end_invariants:
progress_invariants:    
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement
    
    od
} // invariants


init {
    atomic {
        run SuperSuper(_externalEvents[0], _eventProcessed[0]); 
        run Test(_externalEvents[1], _eventProcessed[1]); 
        run invariants(); 
    }
    //(_nr_pr == 1); 
} // init


// ltl claims: run with spin -ltl xyz or spin -noclaim 
//    (F:'';L:83;C:1) Test:ltl: ltlEnd,{,[],(,(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super2,],&&,_currentState,[,state:Super21,],&&,_currentState,[,state:S211,],),->,<>,[],(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super1,],&&,_currentState,[,state:S11,],&&,!,_currentState,[,state:S211,],),),}, (a83)
ltl ltlEnd { [] ( ( _currentState [ idx_state_SuperSuper ] && _currentState [ idx_state_Super2 ] && _currentState [ idx_state_Super21 ] && _currentState [ idx_state_S211 ] ) -> <> [] ( _currentState [ idx_state_SuperSuper ] && _currentState [ idx_state_Super1 ] && _currentState [ idx_state_S11 ] && ! _currentState [ idx_state_S211 ] ) ) } ;
 

//    (F:'';L:74;C:1) Test:chanltl: _internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super21,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211,),;,_externalEvents,[,state:SuperSuper,],!,event:G,;,_internalEvents,[,state:SuperSuper,],!,event:ExitState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super1,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;, (a74)
trace { do :: 
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_Super2 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_Super21 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S211 ) ;
    _externalEvents [ 0 ] ! event_G ;
    _internalEvents [ 0 ] ! event_ExitState ( idx_state_Super2 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_Super1 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S11 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S11 ) ;
    od; }
     



/*UPML end*/

