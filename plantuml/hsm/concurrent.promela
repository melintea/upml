/*
   Generated by UPML v0.09
   Thu Jun 26 16:47:08 2025


    (F:'';L:1;C:1)
    machine concurrent {
        (F:'';L:17;C:1)
        -- m1INr17 _ownedByState:m1 {
            (F:'';L:18;C:1)
            state SuperSuper final:0;initial:1;_superState:m1;_ownedByRegion:m1INr17 {
                (F:'';L:19;C:3) SuperSuper:entry:  (a19)
                (F:'';L:20;C:3) SuperSuper:exit:  (a20)
                (F:'';L:19;C:3)
                -- SuperSuperINr19 _ownedByState:SuperSuper {
                    (F:'';L:45;C:3)
                    state Super1 final:0;initial:0;_superState:SuperSuper;_ownedByRegion:SuperSuperINr19 {
                        (F:'';L:62;C:1) Super1 --> Super2 C[]/ (t62)
                        (F:'';L:64;C:1) Super1 --> SuperSuper D[]/ (t64)
                        (F:'';L:47;C:7) Super1:entry:  (a47)
                        (F:'';L:48;C:7) Super1:exit:  (a48)
                        (F:'';L:46;C:7)
                        -- Super1INr46 _ownedByState:Super1 {
                            (F:'';L:0;C:0)
                            state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr46 {
                                (F:'';L:50;C:7) S11:entry:  (a50)
                                (F:'';L:51;C:7) S11:exit:  (a51)
                            } S11
                        } Super1INr46
                        (F:'';L:54;C:7)
                        -- Super1INr54 _ownedByState:Super1 {
                            (F:'';L:0;C:0)
                            state S11r2 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr54 {
                            } S11r2
                        } Super1INr54
                    } Super1
                    (F:'';L:23;C:3)
                    state Super2 final:0;initial:1;_superState:SuperSuper;_ownedByRegion:SuperSuperINr19 {
                        (F:'';L:61;C:1) Super2 --> Super1 C[]/ (t61)
                        (F:'';L:24;C:7) Super2:entry:  (a24)
                        (F:'';L:25;C:7) Super2:exit:  (a25)
                        (F:'';L:24;C:7)
                        -- Super2INr24 _ownedByState:Super2 {
                            (F:'';L:28;C:7)
                            state Super21 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr24 {
                                (F:'';L:59;C:1) Super21 --> Super21 A[]/ (t59)
                                (F:'';L:29;C:11) Super21:entry:  (a29)
                                (F:'';L:30;C:11) Super21:exit:  (a30)
                                (F:'';L:31;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a31)
                                (F:'';L:29;C:11)
                                -- Super21INr29 _ownedByState:Super21 {
                                    (F:'';L:0;C:0)
                                    state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr29 {
                                        (F:'';L:34;C:11) S211:entry:  (a34)
                                        (F:'';L:35;C:11) S211:exit:  (a35)
                                    } S211
                                } Super21INr29
                                (F:'';L:38;C:11)
                                -- Super21INr38 _ownedByState:Super21 {
                                    (F:'';L:0;C:0)
                                    state S211r2 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr38 {
                                    } S211r2
                                } Super21INr38
                            } Super21
                        } Super2INr24
                        (F:'';L:42;C:7)
                        -- Super2INr42 _ownedByState:Super2 {
                            (F:'';L:0;C:0)
                            state S21r2 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr42 {
                            } S21r2
                        } Super2INr42
                    } Super2
                } SuperSuperINr19
            } SuperSuper
        } m1INr17
        (F:'';L:68;C:1)
        -- m1INr68 _ownedByState:m1 {
            (F:'';L:68;C:1)
            state Test final:1;initial:1;_superState:m1;_ownedByRegion:m1INr68 {
                (F:'';L:71;C:1) Test:entry: send,event:C,to,state:SuperSuper, (a71)
                (F:'';L:72;C:1) Test:chanltl: _internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super21,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S21r2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211r2,),;,_externalEvents,[,state:SuperSuper,],!,event:C,;,_internalEvents,[,state:SuperSuper,],!,event:ExitState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super1,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11r2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11r2,),;, (a72)
                (F:'';L:85;C:1) Test:ltl: ltlEnd,{,[],(,(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super2,],&&,_currentState,[,state:Super21,],&&,_currentState,[,state:S21r2,],&&,_currentState,[,state:S211,],&&,_currentState,[,state:S211r2,],),->,<>,[],(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super1,],&&,_currentState,[,state:S11,],&&,_currentState,[,state:S11r2,],&&,!,_currentState,[,state:S211,],&&,!,_currentState,[,state:S21r2,],&&,!,_currentState,[,state:S211r2,],),),}, (a85)
                (F:'';L:69;C:1)
                -- TestINr69 _ownedByState:Test {
                } TestINr69
            } Test
        } m1INr68
    } concurrent
    
*/


#define idx_unknown 0

#define idx_statusNotProcessed 0
#define idx_statusProcessed 1

#define idx_state_S11 1
#define idx_state_S11r2 2
#define idx_state_S211 3
#define idx_state_S211r2 4
#define idx_state_S21r2 5
#define idx_state_Super1 6
#define idx_state_Super2 7
#define idx_state_Super21 8
#define idx_state_SuperSuper 9
#define idx_state_Test 10
#define numStates 11

bool _currentState[numStates]; 
bool _initialState[numStates]; 

#define initialized (true && _initialState[idx_state_S211] && _initialState[idx_state_S211r2] && _initialState[idx_state_S21r2] && _initialState[idx_state_Super2] && _initialState[idx_state_Super21] && _initialState[idx_state_SuperSuper] && _initialState[idx_state_Test])

#define idx_region_Super1INr46 1
#define idx_region_Super1INr54 2
#define idx_region_Super21INr29 3
#define idx_region_Super21INr38 4
#define idx_region_Super2INr24 5
#define idx_region_Super2INr42 6
#define idx_region_SuperSuperINr19 7
#define idx_region_TestINr69 8
#define idx_region_m1INr17 9
#define idx_region_m1INr68 10

mtype = { event_A, event_C, event_D, event_EnterState, event_ExitState, event_NullEvent, };
typedef event {mtype evId; short toState; short fromState;};
typedef eventStatus {mtype evId; short status;};

int _chanMap[numStates] = {0,0,0,0,0,0,0,0,0,0,1};
chan _externalEvents[2] = [1] of {event};
chan _internalEvents[2] = [2*8] of {event};

chan _eventProcessed[2] = [1] of {eventStatus};

inline send_internal_event(evt, fromState, toState)
{
    assert(nfull(_internalEvents[_chanMap[toState]]));
    _internalEvents[_chanMap[toState]]!evt(toState, fromState);
}

inline send_event(evt, fromState, toState)
{
    (initialized && empty(_internalEvents[_chanMap[toState]]));
    _externalEvents[_chanMap[toState]]!evt(toState, fromState);
    _eventProcessed[_chanMap[toState]]?_(_);
}
            
/*
    (F:'';L:0;C:0)
    state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr29 {
        (F:'';L:34;C:11) S211:entry:  (a34)
        (F:'';L:35;C:11) S211:exit:  (a35)
    } S211
*/
proctype S211(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_S211:
    
    _initialState[idx_state_S211] = 1;
    _currentState[idx_state_S211] = true;

body_S211:
loop_S211:    
    end_S211: superChannel?evtRecv;
    printf("MSC: > S211 event %e in state %d\n", evtRecv.evId, idx_state_S211);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S211) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_S211; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_S211 || evtRecv.toState == idx_unknown)) -> 
       goto exit_S211; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
    goto body_S211;

exit_S211:    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_S211] = false;
} // S211

    
/*
    (F:'';L:0;C:0)
    state S211r2 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr38 {
    } S211r2
*/
proctype S211r2(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_S211r2:
    
    _initialState[idx_state_S211r2] = 1;
    _currentState[idx_state_S211r2] = true;

body_S211r2:
loop_S211r2:    
    end_S211r2: superChannel?evtRecv;
    printf("MSC: > S211r2 event %e in state %d\n", evtRecv.evId, idx_state_S211r2);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S211r2) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_S211r2; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_S211r2 || evtRecv.toState == idx_unknown)) -> 
       goto exit_S211r2; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
    goto body_S211r2;

exit_S211r2:    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_S211r2] = false;
} // S211r2


/*
    (F:'';L:28;C:7)
    state Super21 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr24 {
        (F:'';L:59;C:1) Super21 --> Super21 A[]/ (t59)
        (F:'';L:29;C:11) Super21:entry:  (a29)
        (F:'';L:30;C:11) Super21:exit:  (a30)
        (F:'';L:31;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a31)
        (F:'';L:29;C:11)
        -- Super21INr29 _ownedByState:Super21 {
            (F:'';L:0;C:0)
            state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr29 {
                (F:'';L:34;C:11) S211:entry:  (a34)
                (F:'';L:35;C:11) S211:exit:  (a35)
            } S211
        } Super21INr29
        (F:'';L:38;C:11)
        -- Super21INr38 _ownedByState:Super21 {
            (F:'';L:0;C:0)
            state S211r2 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr38 {
            } S211r2
        } Super21INr38
    } Super21
*/
proctype Super21(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;
    chan substateChannel_Super21INr29 = [1] of {event};
    chan substateChannel_Super21INr38 = [1] of {event};
    chan substateEventProcessedChan = [1] of {eventStatus};

entry_Super21:
    
    _initialState[idx_state_Super21] = 1;
    //    (F:'';L:31;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a31)
    assert((_currentState[idx_state_Super2]&&!_currentState[idx_state_Super1]));
    
    send_internal_event(event_EnterState, idx_state_Super21, idx_state_S211);
    send_internal_event(event_EnterState, idx_state_Super21, idx_state_S211r2);
    _currentState[idx_state_Super21] = true;

body_Super21:
loop_Super21:    
    end_Super21: superChannel?evtRecv;
    printf("MSC: > Super21 event %e in state %d\n", evtRecv.evId, idx_state_Super21);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super21) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super21; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_Super21 || evtRecv.toState == idx_unknown)) -> 
       goto exit_Super21; 
    
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S211) -> 
       run S211(substateChannel_Super21INr29, substateEventProcessedChan);
       _currentState[idx_state_S211] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super21;
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S211r2) -> 
       run S211r2(substateChannel_Super21INr38, substateEventProcessedChan);
       _currentState[idx_state_S211r2] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super21;
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    eventProcessed.status = idx_unknown;
    substateChannel_Super21INr29!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super21;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    eventProcessed.status = idx_unknown;
    substateChannel_Super21INr38!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super21;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_Super21[*/
    if
        
        //    (F:'';L:59;C:1) Super21 --> Super21 A[]/ (t59)
        :: (evtRecv.evId == event_A) -> 
        goto body_Super21;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_Super21;
    fi
    /*]transitions idx_state_Super21*/
    
    } // atomic

exit_Super21:    
    eventProcessed.status = idx_unknown;
    substateChannel_Super21INr29!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessed.status = idx_unknown;
    substateChannel_Super21INr38!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_Super21] = false;
} // Super21

    
/*
    (F:'';L:0;C:0)
    state S21r2 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr42 {
    } S21r2
*/
proctype S21r2(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_S21r2:
    
    _initialState[idx_state_S21r2] = 1;
    _currentState[idx_state_S21r2] = true;

body_S21r2:
loop_S21r2:    
    end_S21r2: superChannel?evtRecv;
    printf("MSC: > S21r2 event %e in state %d\n", evtRecv.evId, idx_state_S21r2);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S21r2) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_S21r2; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_S21r2 || evtRecv.toState == idx_unknown)) -> 
       goto exit_S21r2; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
    goto body_S21r2;

exit_S21r2:    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_S21r2] = false;
} // S21r2


/*
    (F:'';L:23;C:3)
    state Super2 final:0;initial:1;_superState:SuperSuper;_ownedByRegion:SuperSuperINr19 {
        (F:'';L:61;C:1) Super2 --> Super1 C[]/ (t61)
        (F:'';L:24;C:7) Super2:entry:  (a24)
        (F:'';L:25;C:7) Super2:exit:  (a25)
        (F:'';L:24;C:7)
        -- Super2INr24 _ownedByState:Super2 {
            (F:'';L:28;C:7)
            state Super21 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr24 {
                (F:'';L:59;C:1) Super21 --> Super21 A[]/ (t59)
                (F:'';L:29;C:11) Super21:entry:  (a29)
                (F:'';L:30;C:11) Super21:exit:  (a30)
                (F:'';L:31;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a31)
                (F:'';L:29;C:11)
                -- Super21INr29 _ownedByState:Super21 {
                    (F:'';L:0;C:0)
                    state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr29 {
                        (F:'';L:34;C:11) S211:entry:  (a34)
                        (F:'';L:35;C:11) S211:exit:  (a35)
                    } S211
                } Super21INr29
                (F:'';L:38;C:11)
                -- Super21INr38 _ownedByState:Super21 {
                    (F:'';L:0;C:0)
                    state S211r2 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr38 {
                    } S211r2
                } Super21INr38
            } Super21
        } Super2INr24
        (F:'';L:42;C:7)
        -- Super2INr42 _ownedByState:Super2 {
            (F:'';L:0;C:0)
            state S21r2 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr42 {
            } S21r2
        } Super2INr42
    } Super2
*/
proctype Super2(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;
    chan substateChannel_Super2INr24 = [1] of {event};
    chan substateChannel_Super2INr42 = [1] of {event};
    chan substateEventProcessedChan = [1] of {eventStatus};

entry_Super2:
    
    _initialState[idx_state_Super2] = 1;
    send_internal_event(event_EnterState, idx_state_Super2, idx_state_Super21);
    send_internal_event(event_EnterState, idx_state_Super2, idx_state_S21r2);
    _currentState[idx_state_Super2] = true;

body_Super2:
loop_Super2:    
    end_Super2: superChannel?evtRecv;
    printf("MSC: > Super2 event %e in state %d\n", evtRecv.evId, idx_state_Super2);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super2) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super2; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_Super2 || evtRecv.toState == idx_unknown)) -> 
       goto exit_Super2; 
    
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super21) -> 
       run Super21(substateChannel_Super2INr24, substateEventProcessedChan);
       _currentState[idx_state_Super21] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super2;
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S21r2) -> 
       run S21r2(substateChannel_Super2INr42, substateEventProcessedChan);
       _currentState[idx_state_S21r2] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super2;
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    eventProcessed.status = idx_unknown;
    substateChannel_Super2INr24!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super2;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    eventProcessed.status = idx_unknown;
    substateChannel_Super2INr42!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super2;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_Super2[*/
    if
        
        //    (F:'';L:61;C:1) Super2 --> Super1 C[]/ (t61)
        :: (evtRecv.evId == event_C) -> 
        // [*]->ExitState:Super2->[SuperSuper]->EnterState:Super1->[*]
        send_internal_event(event_ExitState, idx_state_Super2, idx_state_Super2);
        send_internal_event(event_EnterState, idx_state_Super2, idx_state_Super1);
        eventProcessedChan!event_C(idx_statusProcessed);
        goto body_Super2;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_Super2;
    fi
    /*]transitions idx_state_Super2*/
    
    } // atomic

exit_Super2:    
    eventProcessed.status = idx_unknown;
    substateChannel_Super2INr24!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessed.status = idx_unknown;
    substateChannel_Super2INr42!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_Super2] = false;
} // Super2

    
/*
    (F:'';L:0;C:0)
    state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr46 {
        (F:'';L:50;C:7) S11:entry:  (a50)
        (F:'';L:51;C:7) S11:exit:  (a51)
    } S11
*/
proctype S11(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_S11:
    
    _initialState[idx_state_S11] = 1;
    _currentState[idx_state_S11] = true;

body_S11:
loop_S11:    
    end_S11: superChannel?evtRecv;
    printf("MSC: > S11 event %e in state %d\n", evtRecv.evId, idx_state_S11);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S11) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_S11; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_S11 || evtRecv.toState == idx_unknown)) -> 
       goto exit_S11; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
    goto body_S11;

exit_S11:    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_S11] = false;
} // S11

    
/*
    (F:'';L:0;C:0)
    state S11r2 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr54 {
    } S11r2
*/
proctype S11r2(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_S11r2:
    
    _initialState[idx_state_S11r2] = 1;
    _currentState[idx_state_S11r2] = true;

body_S11r2:
loop_S11r2:    
    end_S11r2: superChannel?evtRecv;
    printf("MSC: > S11r2 event %e in state %d\n", evtRecv.evId, idx_state_S11r2);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S11r2) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_S11r2; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_S11r2 || evtRecv.toState == idx_unknown)) -> 
       goto exit_S11r2; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
    goto body_S11r2;

exit_S11r2:    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_S11r2] = false;
} // S11r2


/*
    (F:'';L:45;C:3)
    state Super1 final:0;initial:0;_superState:SuperSuper;_ownedByRegion:SuperSuperINr19 {
        (F:'';L:62;C:1) Super1 --> Super2 C[]/ (t62)
        (F:'';L:64;C:1) Super1 --> SuperSuper D[]/ (t64)
        (F:'';L:47;C:7) Super1:entry:  (a47)
        (F:'';L:48;C:7) Super1:exit:  (a48)
        (F:'';L:46;C:7)
        -- Super1INr46 _ownedByState:Super1 {
            (F:'';L:0;C:0)
            state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr46 {
                (F:'';L:50;C:7) S11:entry:  (a50)
                (F:'';L:51;C:7) S11:exit:  (a51)
            } S11
        } Super1INr46
        (F:'';L:54;C:7)
        -- Super1INr54 _ownedByState:Super1 {
            (F:'';L:0;C:0)
            state S11r2 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr54 {
            } S11r2
        } Super1INr54
    } Super1
*/
proctype Super1(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;
    chan substateChannel_Super1INr46 = [1] of {event};
    chan substateChannel_Super1INr54 = [1] of {event};
    chan substateEventProcessedChan = [1] of {eventStatus};

entry_Super1:
    
    _initialState[idx_state_Super1] = 0;
    send_internal_event(event_EnterState, idx_state_Super1, idx_state_S11);
    send_internal_event(event_EnterState, idx_state_Super1, idx_state_S11r2);
    _currentState[idx_state_Super1] = true;

body_Super1:    
    end_Super1: superChannel?evtRecv;
    printf("MSC: > Super1 event %e in state %d\n", evtRecv.evId, idx_state_Super1);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super1) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super1; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_Super1 || evtRecv.toState == idx_unknown)) -> 
       goto exit_Super1; 
    
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S11) -> 
       run S11(substateChannel_Super1INr46, substateEventProcessedChan);
       _currentState[idx_state_S11] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super1;
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_S11r2) -> 
       run S11r2(substateChannel_Super1INr54, substateEventProcessedChan);
       _currentState[idx_state_S11r2] == true;
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Super1;
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    eventProcessed.status = idx_unknown;
    substateChannel_Super1INr46!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super1;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    eventProcessed.status = idx_unknown;
    substateChannel_Super1INr54!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       eventProcessedChan!eventProcessed;
       goto body_Super1;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    // transitions
    atomic {
    eventProcessed.status = idx_unknown;
    
    /* transitions idx_state_Super1[*/
    if
        
        //    (F:'';L:62;C:1) Super1 --> Super2 C[]/ (t62)
        :: (evtRecv.evId == event_C) -> 
        // [*]->ExitState:Super1->[SuperSuper]->EnterState:Super2->[*]
        send_internal_event(event_ExitState, idx_state_Super1, idx_state_Super1);
        send_internal_event(event_EnterState, idx_state_Super1, idx_state_Super2);
        eventProcessedChan!event_C(idx_statusProcessed);
        goto body_Super1;
            
        //    (F:'';L:64;C:1) Super1 --> SuperSuper D[]/ (t64)
        :: (evtRecv.evId == event_D) -> 
        // [*]->ExitState:Super1->ExitState:SuperSuper->[m1]->EnterState:SuperSuper->[*]
        send_internal_event(event_ExitState, idx_state_Super1, idx_state_SuperSuper);
        send_internal_event(event_EnterState, idx_state_Super1, idx_state_SuperSuper);
        eventProcessedChan!event_D(idx_statusProcessed);
        goto body_Super1;
            
        :: else ->
        eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
        goto body_Super1;
    fi
    /*]transitions idx_state_Super1*/
    
    } // atomic

exit_Super1:    
    eventProcessed.status = idx_unknown;
    substateChannel_Super1INr46!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessed.status = idx_unknown;
    substateChannel_Super1INr54!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    eventProcessedChan!event_ExitState(idx_statusProcessed);
    _currentState[idx_state_Super1] = false;
} // Super1


/*
    (F:'';L:18;C:1)
    state SuperSuper final:0;initial:1;_superState:m1;_ownedByRegion:m1INr17 {
        (F:'';L:19;C:3) SuperSuper:entry:  (a19)
        (F:'';L:20;C:3) SuperSuper:exit:  (a20)
        (F:'';L:19;C:3)
        -- SuperSuperINr19 _ownedByState:SuperSuper {
            (F:'';L:45;C:3)
            state Super1 final:0;initial:0;_superState:SuperSuper;_ownedByRegion:SuperSuperINr19 {
                (F:'';L:62;C:1) Super1 --> Super2 C[]/ (t62)
                (F:'';L:64;C:1) Super1 --> SuperSuper D[]/ (t64)
                (F:'';L:47;C:7) Super1:entry:  (a47)
                (F:'';L:48;C:7) Super1:exit:  (a48)
                (F:'';L:46;C:7)
                -- Super1INr46 _ownedByState:Super1 {
                    (F:'';L:0;C:0)
                    state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr46 {
                        (F:'';L:50;C:7) S11:entry:  (a50)
                        (F:'';L:51;C:7) S11:exit:  (a51)
                    } S11
                } Super1INr46
                (F:'';L:54;C:7)
                -- Super1INr54 _ownedByState:Super1 {
                    (F:'';L:0;C:0)
                    state S11r2 final:0;initial:1;_superState:Super1;_ownedByRegion:Super1INr54 {
                    } S11r2
                } Super1INr54
            } Super1
            (F:'';L:23;C:3)
            state Super2 final:0;initial:1;_superState:SuperSuper;_ownedByRegion:SuperSuperINr19 {
                (F:'';L:61;C:1) Super2 --> Super1 C[]/ (t61)
                (F:'';L:24;C:7) Super2:entry:  (a24)
                (F:'';L:25;C:7) Super2:exit:  (a25)
                (F:'';L:24;C:7)
                -- Super2INr24 _ownedByState:Super2 {
                    (F:'';L:28;C:7)
                    state Super21 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr24 {
                        (F:'';L:59;C:1) Super21 --> Super21 A[]/ (t59)
                        (F:'';L:29;C:11) Super21:entry:  (a29)
                        (F:'';L:30;C:11) Super21:exit:  (a30)
                        (F:'';L:31;C:7) Super21:precondition: (,_currentState,[,state:Super2,],&&,!,_currentState,[,state:Super1,],), (a31)
                        (F:'';L:29;C:11)
                        -- Super21INr29 _ownedByState:Super21 {
                            (F:'';L:0;C:0)
                            state S211 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr29 {
                                (F:'';L:34;C:11) S211:entry:  (a34)
                                (F:'';L:35;C:11) S211:exit:  (a35)
                            } S211
                        } Super21INr29
                        (F:'';L:38;C:11)
                        -- Super21INr38 _ownedByState:Super21 {
                            (F:'';L:0;C:0)
                            state S211r2 final:0;initial:1;_superState:Super21;_ownedByRegion:Super21INr38 {
                            } S211r2
                        } Super21INr38
                    } Super21
                } Super2INr24
                (F:'';L:42;C:7)
                -- Super2INr42 _ownedByState:Super2 {
                    (F:'';L:0;C:0)
                    state S21r2 final:0;initial:1;_superState:Super2;_ownedByRegion:Super2INr42 {
                    } S21r2
                } Super2INr42
            } Super2
        } SuperSuperINr19
    } SuperSuper
*/
proctype SuperSuper(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;
    chan substateChannel_SuperSuperINr19 = [1] of {event};
    chan substateEventProcessedChan = [1] of {eventStatus};

entry_SuperSuper:
    
    _initialState[idx_state_SuperSuper] = 1;
    send_internal_event(event_EnterState, idx_state_SuperSuper, idx_state_Super2);
    _currentState[idx_state_SuperSuper] = true;

body_SuperSuper:
loop_SuperSuper:    
    if
    :: nempty(_internalEvents[0]) -> _internalEvents[0]?evtRecv;
    :: initialized && empty(_internalEvents[0])  -> end_SuperSuper: superChannel?evtRecv;
    fi
    printf("MSC: > SuperSuper event %e in state %d\n", evtRecv.evId, idx_state_SuperSuper);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_SuperSuper) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_SuperSuper; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_SuperSuper || evtRecv.toState == idx_unknown)) -> 
       goto exit_SuperSuper; 
    
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super1) -> 
       run Super1(substateChannel_SuperSuperINr19, substateEventProcessedChan);
       _currentState[idx_state_Super1] == true;
       goto body_SuperSuper;
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Super2) -> 
       run Super2(substateChannel_SuperSuperINr19, substateEventProcessedChan);
       _currentState[idx_state_Super2] == true;
       goto body_SuperSuper;
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    eventProcessed.status = idx_unknown;
    substateChannel_SuperSuperINr19!evtRecv;
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.evId == evtRecv.evId);
    if
    :: (eventProcessed.status == idx_statusProcessed) -> 
       if
       :: (evtRecv.evId == event_EnterState || evtRecv.evId == event_ExitState) -> 
          skip;
       :: else -> eventProcessedChan!eventProcessed;
       fi
       goto body_SuperSuper;
    :: else -> assert(eventProcessed.status == idx_statusNotProcessed); skip;
    fi
    
    // transitions
    eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
    goto body_SuperSuper;

exit_SuperSuper:    
    eventProcessed.status = idx_unknown;
    substateChannel_SuperSuperINr19!event_ExitState(idx_unknown, idx_unknown);
    substateEventProcessedChan?eventProcessed;
    assert(eventProcessed.status == idx_statusProcessed);
    
    _currentState[idx_state_SuperSuper] = false;
} // SuperSuper

    
/*
    (F:'';L:68;C:1)
    state Test final:1;initial:1;_superState:m1;_ownedByRegion:m1INr68 {
        (F:'';L:71;C:1) Test:entry: send,event:C,to,state:SuperSuper, (a71)
        (F:'';L:72;C:1) Test:chanltl: _internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super21,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S21r2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211r2,),;,_externalEvents,[,state:SuperSuper,],!,event:C,;,_internalEvents,[,state:SuperSuper,],!,event:ExitState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super1,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11r2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11r2,),;, (a72)
        (F:'';L:85;C:1) Test:ltl: ltlEnd,{,[],(,(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super2,],&&,_currentState,[,state:Super21,],&&,_currentState,[,state:S21r2,],&&,_currentState,[,state:S211,],&&,_currentState,[,state:S211r2,],),->,<>,[],(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super1,],&&,_currentState,[,state:S11,],&&,_currentState,[,state:S11r2,],&&,!,_currentState,[,state:S211,],&&,!,_currentState,[,state:S21r2,],&&,!,_currentState,[,state:S211r2,],),),}, (a85)
        (F:'';L:69;C:1)
        -- TestINr69 _ownedByState:Test {
        } TestINr69
    } Test
*/
proctype Test(chan superChannel; chan eventProcessedChan) 
{
    local event evtRecv;
    local eventStatus eventProcessed;

entry_Test:
    
    _initialState[idx_state_Test] = 1;
    //    (F:'';L:71;C:1) Test:entry: send,event:C,to,state:SuperSuper, (a71)
    send_event(event_C, idx_state_Test, idx_state_SuperSuper); 
    
    _currentState[idx_state_Test] = true;

body_Test:
loop_Test:    
    if
    :: nempty(_internalEvents[1]) -> _internalEvents[1]?evtRecv;
    :: initialized && empty(_internalEvents[1])  -> end_Test: superChannel?evtRecv;
    fi
    printf("MSC: > Test event %e in state %d\n", evtRecv.evId, idx_state_Test);
    
    if
    :: (evtRecv.evId == event_EnterState && evtRecv.toState == idx_state_Test) -> 
       eventProcessedChan!event_EnterState(idx_statusProcessed);
       goto body_Test; 
    
    :: (evtRecv.evId == event_ExitState && (evtRecv.toState == idx_state_Test || evtRecv.toState == idx_unknown)) -> 
       goto exit_Test; 
    
    :: else -> skip; // send to substates for processing
    fi
    
    // send event to substates, check if processed
    // transitions
    eventProcessedChan!evtRecv.evId(idx_statusNotProcessed);
    goto body_Test;

exit_Test:    
    _currentState[idx_state_Test] = false;
} // Test



proctype invariants() {
end_invariants:
progress_invariants:    
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement
    
    od
} // invariants


init {
    atomic {
        run SuperSuper(_externalEvents[0], _eventProcessed[0]); 
        run Test(_externalEvents[1], _eventProcessed[1]); 
        run invariants(); 
    }
    //(_nr_pr == 1); 
} // init


// ltl claims: run with spin -ltl xyz or spin -noclaim 
//    (F:'';L:85;C:1) Test:ltl: ltlEnd,{,[],(,(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super2,],&&,_currentState,[,state:Super21,],&&,_currentState,[,state:S21r2,],&&,_currentState,[,state:S211,],&&,_currentState,[,state:S211r2,],),->,<>,[],(,_currentState,[,state:SuperSuper,],&&,_currentState,[,state:Super1,],&&,_currentState,[,state:S11,],&&,_currentState,[,state:S11r2,],&&,!,_currentState,[,state:S211,],&&,!,_currentState,[,state:S21r2,],&&,!,_currentState,[,state:S211r2,],),),}, (a85)
ltl ltlEnd { [] ( ( _currentState [ idx_state_SuperSuper ] && _currentState [ idx_state_Super2 ] && _currentState [ idx_state_Super21 ] && _currentState [ idx_state_S21r2 ] && _currentState [ idx_state_S211 ] && _currentState [ idx_state_S211r2 ] ) -> <> [] ( _currentState [ idx_state_SuperSuper ] && _currentState [ idx_state_Super1 ] && _currentState [ idx_state_S11 ] && _currentState [ idx_state_S11r2 ] && ! _currentState [ idx_state_S211 ] && ! _currentState [ idx_state_S21r2 ] && ! _currentState [ idx_state_S211r2 ] ) ) } ;
 

//    (F:'';L:72;C:1) Test:chanltl: _internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super21,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S21r2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S211r2,),;,_externalEvents,[,state:SuperSuper,],!,event:C,;,_internalEvents,[,state:SuperSuper,],!,event:ExitState,(,state:Super2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:Super1,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11r2,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11,),;,_internalEvents,[,state:SuperSuper,],!,event:EnterState,(,state:S11r2,),;, (a72)
trace { do :: 
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_Super2 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_Super21 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S21r2 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S211 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S211r2 ) ;
    _externalEvents [ 0 ] ! event_C ;
    _internalEvents [ 0 ] ! event_ExitState ( idx_state_Super2 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_Super1 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S11 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S11r2 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S11 ) ;
    _internalEvents [ 0 ] ! event_EnterState ( idx_state_S11r2 ) ;
    od; }
     



/*UPML end*/

