/*
./upml --in ../plantuml/hsm/hsm2.plantuml --backend spin --out ../plantuml/hsm/hsm2.promela 
*/
/*
   Generated by UPML v0.06
   Thu Mar 13 10:04:56 2025


    (F:'';L:1;C:1)
    machine hsm2 {
        (F:'';L:10;C:1)
        -- r10 _ownedByState:m1 {
            (F:'';L:10;C:1)
            state SuperSuper final:0;initial:1;_superState:m1;_ownedByRegion:r10 {
                (F:'';L:31;C:3) SuperSuper:entry: trace,SuperSuper, (a31)
                (F:'';L:12;C:3)
                -- r12 _ownedByState:SuperSuper {
                    (F:'';L:12;C:3)
                    state Super1 final:0;initial:1;_superState:SuperSuper;_ownedByRegion:r12 {
                        (F:'';L:33;C:3) Super1 --> Super2 T1[]/trace,t1, (t33)
                        (F:'';L:14;C:7) Super1:entry: trace,Super1_entry, (a14)
                        (F:'';L:15;C:7) Super1:exit: trace,Super1_exit, (a15)
                        (F:'';L:13;C:7)
                        -- r13 _ownedByState:Super1 {
                            (F:'';L:0;C:0)
                            state S11 final:0;initial:1;_superState:Super1;_ownedByRegion:r13 {
                                (F:'';L:17;C:7) S11:entry: trace,S11_entry, (a17)
                                (F:'';L:18;C:7) S11:exit: trace,S11_exit, (a18)
                            } S11
                        } r13
                    } Super1
                    (F:'';L:21;C:3)
                    state Super2 final:0;initial:0;_superState:SuperSuper;_ownedByRegion:r12 {
                        (F:'';L:23;C:7) Super2:entry: trace,Super2_entry, (a23)
                        (F:'';L:24;C:7) Super2:exit: trace,Super2_exit, (a24)
                        (F:'';L:22;C:7)
                        -- r22 _ownedByState:Super2 {
                            (F:'';L:0;C:0)
                            state S21 final:0;initial:1;_superState:Super2;_ownedByRegion:r22 {
                                (F:'';L:26;C:7) S21:entry: trace,S21_entry, (a26)
                                (F:'';L:27;C:7) S21:exit: trace,S21_exit, (a27)
                            } S21
                        } r22
                    } Super2
                } r12
            } SuperSuper
        } r10
    } hsm2
    
*/


#define idx_unknown -1

#define idx_state_S11 0
#define idx_state_S21 1
#define idx_state_Super1 2
#define idx_state_Super2 3
#define idx_state_SuperSuper 4

#define idx_region_r10 0
#define idx_region_r12 1
#define idx_region_r13 2
#define idx_region_r22 3

mtype = { event_EnterState, event_ExitState, event_NullEvent, event_SuperSuper, event_T1, event_entry, event_exit, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[4] = [4] of {event};

inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_r10() // hsm2
{
    local short myIdx = idx_region_r10;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_SuperSuper; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_SuperSuper[*/

entry_SuperSuper:    
    currentState = newState;
    noChannel = true;
    
    //    (F:'';L:31;C:3) SuperSuper:entry: trace,SuperSuper, (a31)
    printf("SuperSuper \n"); 
    

body_SuperSuper:
loop_SuperSuper:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_r10 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_SuperSuper*/

} // region_r10 hsm2


proctype region_r12() // SuperSuper
{
    local short myIdx = idx_region_r12;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_Super1; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_Super1[*/

entry_Super1:    
    currentState = newState;
    
    //    (F:'';L:14;C:7) Super1:entry: trace,Super1_entry, (a14)
    printf("Super1_entry \n"); 
    

body_Super1:
loop_Super1:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_r12 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_Super1[*/
    if
        
        //    (F:'';L:33;C:3) Super1 --> Super2 T1[]/trace,t1, (t33)
        :: (evtRecv.evId == event_T1) -> printf("t1 \n"); 
        
        //    (F:'';L:15;C:7) Super1:exit: trace,Super1_exit, (a15)
        :: (currentState == idx_state_Super1) -> printf("Super1_exit \n"); 
            
            newState = idx_state_Super2; 
            goto entry_Super2;
        
    fi
    /*]transitions idx_state_Super1*/
    
/*]state idx_state_Super1*/


/* state idx_state_Super2[*/

entry_Super2:    
    currentState = newState;
    noChannel = true;
    
    //    (F:'';L:23;C:7) Super2:entry: trace,Super2_entry, (a23)
    printf("Super2_entry \n"); 
    

body_Super2:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_r12 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Super2*/

} // region_r12 SuperSuper


proctype region_r13() // Super1
{
    local short myIdx = idx_region_r13;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_S11; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_S11[*/

entry_S11:    
    currentState = newState;
    noChannel = true;
    
    //    (F:'';L:17;C:7) S11:entry: trace,S11_entry, (a17)
    printf("S11_entry \n"); 
    

body_S11:
loop_S11:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_r13 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_S11*/

} // region_r13 Super1


proctype region_r22() // Super2
{
    local short myIdx = idx_region_r22;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_S21; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 


/* state idx_state_S21[*/

entry_S21:    
    currentState = newState;
    noChannel = true;
    
    //    (F:'';L:26;C:7) S21:entry: trace,S21_entry, (a26)
    printf("S21_entry \n"); 
    

body_S21:
loop_S21:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_r22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_S21*/

} // region_r22 Super2


proctype invariants() {
end_invariants:
progress_invariants:    
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement
    
od
} // invariants


init {
    atomic {
        run region_r10(); 
        run region_r12(); 
        run region_r13(); 
        run region_r22(); 
        run invariants(); 
    }
    //(_nr_pr == 1); 
} // init


// ltl claims: run with spin -ltl xyz or spin -noclaim 


/*UPML end*/

