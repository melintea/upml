/*
./upml --in ../plantuml/hsm/hsm2.plantuml --backend tla --out ../plantuml/hsm/hsm2.tla 
*/
/*
   Generated by UPML v0.05
   Mon Dec  9 13:17:51 2024


    (F:'';L:1;C:1)
    machine hsm2 {
        (F:'';L:10;C:1)
        -- r10 {
            (F:'';L:10;C:1)
            state SuperSuper final:0;initial:1 {
                (F:'';L:12;C:3)
                -- r12 {
                    (F:'';L:12;C:3)
                    state Super1 final:0;initial:1 {
                        (F:'';L:33;C:3) Super1 --> Super2 T1[g,(,),]/trace,t1, (t33)
                        (F:'';L:13;C:7)
                        -- r13 {
                            (F:'';L:0;C:0)
                            state S11 final:0;initial:1 {
                                (F:'';L:17;C:7) S11:entry: trace,S11_entry, (a17)
                                (F:'';L:18;C:7) S11:exit: trace,S11_exit, (a18)
                            }
                            (F:'';L:0;C:0)
                            state Super1 final:0;initial:0 {
                                (F:'';L:14;C:7) Super1:entry: trace,Super1_entry, (a14)
                                (F:'';L:15;C:7) Super1:exit: trace,Super1_exit, (a15)
                            }
                        }
                    }
                    (F:'';L:21;C:3)
                    state Super2 final:0;initial:0 {
                        (F:'';L:22;C:7)
                        -- r22 {
                            (F:'';L:0;C:0)
                            state S21 final:0;initial:1 {
                                (F:'';L:26;C:7) S21:entry: trace,S21_entry, (a26)
                                (F:'';L:27;C:7) S21:exit: trace,S21_exit, (a27)
                            }
                            (F:'';L:0;C:0)
                            state Super2 final:0;initial:0 {
                                (F:'';L:23;C:7) Super2:entry: trace,Super2_entry, (a23)
                                (F:'';L:24;C:7) Super2:exit: trace,Super2_exit, (a24)
                            }
                        }
                    }
                    (F:'';L:0;C:0)
                    state SuperSuper final:0;initial:0 {
                        (F:'';L:31;C:3) SuperSuper:entry: trace,SuperSuper, (a31)
                    }
                }
            }
        }
    } hsm2

*/

---- MODULE hsm2 ----------------------------------------------------

EXTENDS TLC, Integers, Sequences

idx_Unknown == -1

idx_state_S11 == 1
idx_state_S21 == 2
idx_state_Super1 == 3
idx_state_Super2 == 4
idx_state_SuperSuper == 5

idx_region_r10 == 1
idx_region_r12 == 2
idx_region_r13 == 3
idx_region_r22 == 4

idx_event_NullEvent == 4
idx_event_SuperSuper == 9
idx_event_T1 == 10
idx_event_entry == 7
idx_event_exit == 8

(**********************************************************************

--algorithm hsm2 {

variables

    procs = { idx_region_r10, idx_region_r12, idx_region_r13, idx_region_r22 };
    channels = [p \in procs |-> <<>>];
    currentState = [p \in procs |-> idx_Unknown];
    stateTransitions = { "t33" };
    visitedTransitions = [t \in stateTransitions |-> FALSE];
    maxUmlEvents = -20;  \* limit the number of UML events in the run

\* Add to the Properties box of the model
define {
    \* Limit the number of UML events to maxUmlEvents; if reached this will show as a model run error
    MaxEventsReached == 
        /\ [](maxUmlEvents < 0)
    \* Flag dead transitions as errors
    AllTransitionsVisited == 
        /\ <>(\A t \in DOMAIN visitedTransitions : visitedTransitions[t] = TRUE)
    \* As extracted from the plantuml spec:
    UmlInvariants == 
        /\ [](TRUE) \* ensure not empty
    }; 


macro send_event(channel, evtId, fromState, toState) {
    print <<"P:", fromState, "o->", evtId, channel, " > P:", toState>>;
    channels[channel] := Append(@, evtId);
    maxUmlEvents := maxUmlEvents + 1;
}
macro recv_event(evtId, channel, inState) {
    await Len(channels[channel]) > 0;
    evtId := Head(channels[channel]);
    print <<"P:", channel, inState, "<-i", evtId>>;
    channels[channel] := Tail(@);
}

    

fair+ process (region_r10 \in {idx_region_r10}) \* hsm2
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_SuperSuper; 
    finalState = idx_Unknown; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r10: currentState[self] := initialState;

\* state idx_state_SuperSuper[

entry_SuperSuper: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_SuperSuper: skip;
loop_SuperSuper: skip;
    if ( noChannel = FALSE ) {
        L1:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_SuperSuper

} \* region_r10 hsm2


fair+ process (region_r12 \in {idx_region_r12}) \* SuperSuper
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_Super1; 
    finalState = idx_Unknown; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r12: currentState[self] := initialState;

\* state idx_state_Super1[

entry_Super1: skip;
    currentState[self] := newState;


body_Super1: skip;
loop_Super1: skip;
    if ( noChannel = FALSE ) {
        L2:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


    \* transitions idx_state_Super1[ 
    L3:
    \* either {

        \*     (F:'';L:33;C:3) Super1 --> Super2 T1[g,(,),]/trace,t1, (t33)
        await (evtRecv = idx_event_T1 /\ g());print <<"t1 ", "\n">>; 

        visitedTransitions["t33"] := TRUE;

        newState := idx_state_Super2; 
        goto entry_Super2;

    \* }; \* either
    \*]transitions idx_state_Super1

\*]state idx_state_Super1


\* state idx_state_Super2[

entry_Super2: skip;
    currentState[self] := newState;
    noChannel := TRUE;


body_Super2: skip;
    if ( noChannel = FALSE ) {
        L4:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_Super2


\* state idx_state_SuperSuper[

entry_SuperSuper: skip;
    currentState[self] := newState;
    noChannel := TRUE;

    \*     (F:'';L:31;C:3) SuperSuper:entry: trace,SuperSuper, (a31)
    print <<"SuperSuper ", "\n">>; 


body_SuperSuper: skip;
    if ( noChannel = FALSE ) {
        L5:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_SuperSuper

} \* region_r12 SuperSuper


fair+ process (region_r13 \in {idx_region_r13}) \* Super1
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_S11; 
    finalState = idx_Unknown; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r13: currentState[self] := initialState;

\* state idx_state_S11[

entry_S11: skip;
    currentState[self] := newState;
    noChannel := TRUE;

    \*     (F:'';L:17;C:7) S11:entry: trace,S11_entry, (a17)
    print <<"S11_entry ", "\n">>; 


body_S11: skip;
loop_S11: skip;
    if ( noChannel = FALSE ) {
        L6:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_S11


\* state idx_state_Super1[

entry_Super1: skip;
    currentState[self] := newState;
    noChannel := TRUE;

    \*     (F:'';L:14;C:7) Super1:entry: trace,Super1_entry, (a14)
    print <<"Super1_entry ", "\n">>; 


body_Super1: skip;
    if ( noChannel = FALSE ) {
        L7:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_Super1

} \* region_r13 Super1


fair+ process (region_r22 \in {idx_region_r22}) \* Super2
variables
    evtRecv = idx_Unknown; 
    initialState = idx_state_S21; 
    finalState = idx_Unknown; 
    newState = initialState; 
    noChannel = FALSE; 
{
proc_body_idx_region_r22: currentState[self] := initialState;

\* state idx_state_S21[

entry_S21: skip;
    currentState[self] := newState;
    noChannel := TRUE;

    \*     (F:'';L:26;C:7) S21:entry: trace,S21_entry, (a26)
    print <<"S21_entry ", "\n">>; 


body_S21: skip;
loop_S21: skip;
    if ( noChannel = FALSE ) {
        L8:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_S21


\* state idx_state_Super2[

entry_Super2: skip;
    currentState[self] := newState;
    noChannel := TRUE;

    \*     (F:'';L:23;C:7) Super2:entry: trace,Super2_entry, (a23)
    print <<"Super2_entry ", "\n">>; 


body_Super2: skip;
    if ( noChannel = FALSE ) {
        L9:recv_event(evtRecv, self, currentState[self]); 
    } else {
        evtRecv := idx_event_NullEvent;
    };


\*]state idx_state_Super2

} \* region_r22 Super2


} \* algorithm hsm2

**********************************************************************)



=======================================================================
