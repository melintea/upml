/*
/home/amelinte/work/github/upml/src/upml --in /home/amelinte/work/github/upml/plantuml/fsm/switch/switch.plantuml --backend spin-fsm --out ../plantuml/fsm/switch/switch.promela 
*/
/*
   Generated by UPML v0.09
   Wed Jun 18 17:35:23 2025


    (F:'';L:1;C:1)
    machine switch {
        (F:'';L:17;C:1)
        -- m1INr17 _ownedByState:m1 {
            (F:'';L:17;C:1)
            state Human final:0;initial:0;_superState:m1;_ownedByRegion:m1INr17 {
                (F:'';L:30;C:1) Human:ltl: ltlLight,{,<>,[],(,state:Switch:currentState,==,state:BothOff,&&,lightOn,==,false,),->,(,state:Switch:currentState,==,state:On,&&,lightOn,==,true,),->,(,state:Switch:currentState,==,state:BothOff,&&,lightOn,==,false,&&,state:Human:currentState,==,state:Done,),}, (a30)
                (F:'';L:19;C:1)
                -- HumanINr19 _ownedByState:Human {
                    (F:'';L:0;C:0)
                    state Done final:1;initial:0;_superState:Human;_ownedByRegion:HumanINr19 {
                    } Done
                    (F:'';L:0;C:0)
                    state TurnLightOff final:0;initial:0;_superState:Human;_ownedByRegion:HumanINr19 {
                        (F:'';L:25;C:1) TurnLightOff --> Done NullEvent[]/send,event:LampSwitch,to,state:Switch,;,send,event:WallSwitch,to,state:Switch,;, (t25)
                        (F:'';L:26;C:1) TurnLightOff --> Done NullEvent[]/send,event:WallSwitch,to,state:Switch,;,send,event:LampSwitch,to,state:Switch,;, (t26)
                        noInboundEvents,
                    } TurnLightOff
                    (F:'';L:0;C:0)
                    state TurnLightOn final:0;initial:1;_superState:Human;_ownedByRegion:HumanINr19 {
                        (F:'';L:21;C:1) TurnLightOn --> TurnLightOff NullEvent[]/send,event:LampSwitch,to,state:Switch,;,send,event:WallSwitch,to,state:Switch,;, (t21)
                        (F:'';L:22;C:1) TurnLightOn --> TurnLightOff NullEvent[]/send,event:WallSwitch,to,state:Switch,;,send,event:LampSwitch,to,state:Switch,;, (t22)
                        noInboundEvents,
                    } TurnLightOn
                } HumanINr19
            } Human
            (F:'';L:35;C:1)
            state Switch final:0;initial:0;_superState:m1;_ownedByRegion:m1INr17 {
                (F:'';L:37;C:1) Switch:globalvar: bool,lightOn,=,false, (a37)
                (F:'';L:37;C:1)
                -- SwitchINr37 _ownedByState:Switch {
                    (F:'';L:0;C:0)
                    state BothOff final:1;initial:1;_superState:Switch;_ownedByRegion:SwitchINr37 {
                        (F:'';L:41;C:1) BothOff --> WallOff LampSwitch[]/ (t41)
                        (F:'';L:42;C:1) BothOff --> LampOff WallSwitch[]/ (t42)
                        progressTag,
                    } BothOff
                    (F:'';L:0;C:0)
                    state LampOff final:0;initial:0;_superState:Switch;_ownedByRegion:SwitchINr37 {
                        (F:'';L:49;C:1) LampOff --> BothOff WallSwitch[]/ (t49)
                        (F:'';L:50;C:1) LampOff --> On LampSwitch[]/ (t50)
                        progressTag,
                    } LampOff
                    (F:'';L:0;C:0)
                    state On final:0;initial:0;_superState:Switch;_ownedByRegion:SwitchINr37 {
                        (F:'';L:53;C:1) On --> WallOff WallSwitch[]/ (t53)
                        (F:'';L:54;C:1) On --> LampOff LampSwitch[]/ (t54)
                        (F:'';L:56;C:1) On:entry: lightOn,=,true, (a56)
                        (F:'';L:57;C:1) On:exit: lightOn,=,false, (a57)
                        progressTag,
                    } On
                    (F:'';L:0;C:0)
                    state WallOff final:0;initial:0;_superState:Switch;_ownedByRegion:SwitchINr37 {
                        (F:'';L:46;C:1) WallOff --> On WallSwitch[]/ (t46)
                        (F:'';L:47;C:1) WallOff --> BothOff LampSwitch[]/ (t47)
                        progressTag,
                    } WallOff
                } SwitchINr37
            } Switch
        } m1INr17
    } switch
    
*/


#define idx_unknown -1

#define idx_state_BothOff 0
#define idx_state_Done 1
#define idx_state_Human 2
#define idx_state_LampOff 3
#define idx_state_On 4
#define idx_state_Switch 5
#define idx_state_TurnLightOff 6
#define idx_state_TurnLightOn 7
#define idx_state_WallOff 8

#define idx_region_HumanINr19 0
#define idx_region_SwitchINr37 1
#define idx_region_m1INr17 2

mtype = { event_EnterState, event_ExitState, event_LampSwitch, event_NullEvent, event_WallSwitch, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[3] = [3] of {event}; 

//    (F:'';L:37;C:1) Switch:globalvar: bool,lightOn,=,false, (a37)
bool lightOn = false ;


inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_m1INr17() // switch
{
    local short myIdx = idx_region_m1INr17;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_unknown; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_Human[*/

entry_Human:    
    currentState = newState;
    noChannel = true;
    

body_Human:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_m1INr17 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Human*/


/* state idx_state_Switch[*/

entry_Switch:    
    currentState = newState;
    noChannel = true;
    

body_Switch:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_m1INr17 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Switch*/

} // region_m1INr17 switch


proctype region_HumanINr19() // Human
{
    local short myIdx = idx_region_HumanINr19;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_TurnLightOn; 
    local short finalState = idx_state_Done; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_TurnLightOn[*/

entry_TurnLightOn:    
    currentState = newState;
    noChannel = true;
    

body_TurnLightOn:
loop_TurnLightOn:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_HumanINr19 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_TurnLightOn[*/
    if
        
        //    (F:'';L:21;C:1) TurnLightOn --> TurnLightOff NullEvent[]/send,event:LampSwitch,to,state:Switch,;,send,event:WallSwitch,to,state:Switch,;, (t21)
        :: (evtRecv.evId == event_NullEvent) -> 
        //    (F:'';L:0;C:0) idx_state_TurnLightOn:send: send,event:LampSwitch,to,state:Switch,;,send,event:WallSwitch,to,state:Switch,;, (a21)
        send_event(idx_region_SwitchINr37, event_LampSwitch, idx_state_TurnLightOn, idx_state_Switch); 
        send_event(idx_region_SwitchINr37, event_WallSwitch, idx_state_TurnLightOn, idx_state_Switch); 
        
        newState = idx_state_TurnLightOff; 
        goto entry_TurnLightOff;
            
        //    (F:'';L:22;C:1) TurnLightOn --> TurnLightOff NullEvent[]/send,event:WallSwitch,to,state:Switch,;,send,event:LampSwitch,to,state:Switch,;, (t22)
        :: (evtRecv.evId == event_NullEvent) -> 
        //    (F:'';L:0;C:0) idx_state_TurnLightOn:send: send,event:WallSwitch,to,state:Switch,;,send,event:LampSwitch,to,state:Switch,;, (a22)
        send_event(idx_region_SwitchINr37, event_WallSwitch, idx_state_TurnLightOn, idx_state_Switch); 
        send_event(idx_region_SwitchINr37, event_LampSwitch, idx_state_TurnLightOn, idx_state_Switch); 
        
        newState = idx_state_TurnLightOff; 
        goto entry_TurnLightOff;
        
    fi
    /*]transitions idx_state_TurnLightOn*/
    
/*]state idx_state_TurnLightOn*/


/* state idx_state_TurnLightOff[*/

entry_TurnLightOff:    
    currentState = newState;
    noChannel = true;
    

body_TurnLightOff:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_HumanINr19 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_TurnLightOff[*/
    if
        
        //    (F:'';L:25;C:1) TurnLightOff --> Done NullEvent[]/send,event:LampSwitch,to,state:Switch,;,send,event:WallSwitch,to,state:Switch,;, (t25)
        :: (evtRecv.evId == event_NullEvent) -> 
        //    (F:'';L:0;C:0) idx_state_TurnLightOff:send: send,event:LampSwitch,to,state:Switch,;,send,event:WallSwitch,to,state:Switch,;, (a25)
        send_event(idx_region_SwitchINr37, event_LampSwitch, idx_state_TurnLightOff, idx_state_Switch); 
        send_event(idx_region_SwitchINr37, event_WallSwitch, idx_state_TurnLightOff, idx_state_Switch); 
        
        newState = idx_state_Done; 
        goto entry_Done;
            
        //    (F:'';L:26;C:1) TurnLightOff --> Done NullEvent[]/send,event:WallSwitch,to,state:Switch,;,send,event:LampSwitch,to,state:Switch,;, (t26)
        :: (evtRecv.evId == event_NullEvent) -> 
        //    (F:'';L:0;C:0) idx_state_TurnLightOff:send: send,event:WallSwitch,to,state:Switch,;,send,event:LampSwitch,to,state:Switch,;, (a26)
        send_event(idx_region_SwitchINr37, event_WallSwitch, idx_state_TurnLightOff, idx_state_Switch); 
        send_event(idx_region_SwitchINr37, event_LampSwitch, idx_state_TurnLightOff, idx_state_Switch); 
        
        newState = idx_state_Done; 
        goto entry_Done;
        
    fi
    /*]transitions idx_state_TurnLightOff*/
    
/*]state idx_state_TurnLightOff*/


/* state idx_state_Done[*/

entry_Done:    
    currentState = newState;
    noChannel = true;
    

body_Done:
loop_Done:    
    if
    :: ( noChannel == false ) -> end_Done:
        myChan?evtRecv; 
        printf("MSC: > %d region_HumanINr19 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Done*/

} // region_HumanINr19 Human


proctype region_SwitchINr37() // Switch
{
    local short myIdx = idx_region_SwitchINr37;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_BothOff; 
    local short finalState = idx_state_BothOff; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_BothOff[*/

entry_BothOff:    
    currentState = newState;
    

body_BothOff:
loop_BothOff:
progress_BothOff:    
    if
    :: ( noChannel == false ) -> end_BothOff:
        myChan?evtRecv; 
        printf("MSC: > %d region_SwitchINr37 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_BothOff[*/
    if
        
        //    (F:'';L:41;C:1) BothOff --> WallOff LampSwitch[]/ (t41)
        :: (evtRecv.evId == event_LampSwitch) -> 
        newState = idx_state_WallOff; 
        goto entry_WallOff;
            
        //    (F:'';L:42;C:1) BothOff --> LampOff WallSwitch[]/ (t42)
        :: (evtRecv.evId == event_WallSwitch) -> 
        newState = idx_state_LampOff; 
        goto entry_LampOff;
        
    fi
    /*]transitions idx_state_BothOff*/
    
/*]state idx_state_BothOff*/


/* state idx_state_LampOff[*/

entry_LampOff:    
    currentState = newState;
    

body_LampOff:
progress_LampOff:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_SwitchINr37 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_LampOff[*/
    if
        
        //    (F:'';L:49;C:1) LampOff --> BothOff WallSwitch[]/ (t49)
        :: (evtRecv.evId == event_WallSwitch) -> 
        newState = idx_state_BothOff; 
        goto entry_BothOff;
            
        //    (F:'';L:50;C:1) LampOff --> On LampSwitch[]/ (t50)
        :: (evtRecv.evId == event_LampSwitch) -> 
        newState = idx_state_On; 
        goto entry_On;
        
    fi
    /*]transitions idx_state_LampOff*/
    
/*]state idx_state_LampOff*/


/* state idx_state_On[*/

entry_On:    
    currentState = newState;
    
    //    (F:'';L:56;C:1) On:entry: lightOn,=,true, (a56)
    lightOn = true ;
    

body_On:
progress_On:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_SwitchINr37 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_On[*/
    if
        
        //    (F:'';L:53;C:1) On --> WallOff WallSwitch[]/ (t53)
        :: (evtRecv.evId == event_WallSwitch) -> 
        //    (F:'';L:57;C:1) On:exit: lightOn,=,false, (a57)
        lightOn = false ;
        
        newState = idx_state_WallOff; 
        goto entry_WallOff;
            
        //    (F:'';L:54;C:1) On --> LampOff LampSwitch[]/ (t54)
        :: (evtRecv.evId == event_LampSwitch) -> 
        //    (F:'';L:57;C:1) On:exit: lightOn,=,false, (a57)
        lightOn = false ;
        
        newState = idx_state_LampOff; 
        goto entry_LampOff;
        
    fi
    /*]transitions idx_state_On*/
    
/*]state idx_state_On*/


/* state idx_state_WallOff[*/

entry_WallOff:    
    currentState = newState;
    

body_WallOff:
progress_WallOff:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_SwitchINr37 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_WallOff[*/
    if
        
        //    (F:'';L:46;C:1) WallOff --> On WallSwitch[]/ (t46)
        :: (evtRecv.evId == event_WallSwitch) -> 
        newState = idx_state_On; 
        goto entry_On;
            
        //    (F:'';L:47;C:1) WallOff --> BothOff LampSwitch[]/ (t47)
        :: (evtRecv.evId == event_LampSwitch) -> 
        newState = idx_state_BothOff; 
        goto entry_BothOff;
        
    fi
    /*]transitions idx_state_WallOff*/
    
/*]state idx_state_WallOff*/

} // region_SwitchINr37 Switch


proctype invariants() {
end_invariants:
progress_invariants:    
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement
    
    od
} // invariants


init {
    atomic {
        run region_HumanINr19(); 
        run region_SwitchINr37(); 
        run region_m1INr17(); 
        run invariants(); 
    }
    //(_nr_pr == 1); 
} // init


// ltl claims: run with spin -ltl xyz or spin -noclaim 
//    (F:'';L:30;C:1) Human:ltl: ltlLight,{,<>,[],(,state:Switch:currentState,==,state:BothOff,&&,lightOn,==,false,),->,(,state:Switch:currentState,==,state:On,&&,lightOn,==,true,),->,(,state:Switch:currentState,==,state:BothOff,&&,lightOn,==,false,&&,state:Human:currentState,==,state:Done,),}, (a30)
ltl ltlLight { <> [] ( region_SwitchINr37:currentState  == idx_state_BothOff && lightOn == false ) -> ( region_SwitchINr37:currentState  == idx_state_On && lightOn == true ) -> ( region_SwitchINr37:currentState  == idx_state_BothOff && lightOn == false && region_HumanINr19:currentState  == idx_state_Done ) } ;
 





/*UPML end*/

