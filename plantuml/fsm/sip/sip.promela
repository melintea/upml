/*
/home/amelinte/work/github/upml/src/upml --in /home/amelinte/work/github/upml/plantuml/fsm/sip/sip.plantuml --backend spin-fsm --out ../plantuml/fsm/sip/sip.promela 
*/
/*
   Generated by UPML v0.08
   Wed Jun  4 10:25:03 2025


    (F:'';L:1;C:1)
    machine sip {
        (F:'';L:3;C:1)
        -- m1INr3 _ownedByState:m1 {
            (F:'';L:21;C:1)
            state Alice final:0;initial:0;_superState:m1;_ownedByRegion:m1INr3 {
                (F:'';L:22;C:3)
                -- AliceINr22 _ownedByState:Alice {
                    (F:'';L:0;C:0)
                    state AEstablished final:0;initial:0;_superState:Alice;_ownedByRegion:AliceINr22 {
                        (F:'';L:30;C:3) AEstablished --> Aterminated Hangup[]/ (t30)
                        (F:'';L:29;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a29)
                    } AEstablished
                    (F:'';L:0;C:0)
                    state AIdle final:0;initial:1;_superState:Alice;_ownedByRegion:AliceINr22 {
                        (F:'';L:23;C:3) AIdle --> AInitiated Dial[]/ (t23)
                    } AIdle
                    (F:'';L:0;C:0)
                    state AInitiated final:0;initial:0;_superState:Alice;_ownedByRegion:AliceINr22 {
                        (F:'';L:26;C:3) AInitiated --> AInitiated 1xx[]/ (t26)
                        (F:'';L:27;C:3) AInitiated --> AEstablished 2xx[]/ (t27)
                        (F:'';L:25;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a25)
                        (F:'';L:36;C:3) AInitiated:precondition: (,state:Alice:currentState,!=,state:BIdle,), (a36)
                        (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)
                        (F:'';L:38;C:3) AInitiated:invariant: (,state:Alice:currentState,!=,state:Bterminated,), (a38)
                    } AInitiated
                    (F:'';L:0;C:0)
                    state Aterminated final:1;initial:0;_superState:Alice;_ownedByRegion:AliceINr22 {
                        (F:'';L:32;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a32)
                    } Aterminated
                } AliceINr22
            } Alice
            (F:'';L:43;C:1)
            state Bob final:0;initial:0;_superState:m1;_ownedByRegion:m1INr3 {
                (F:'';L:44;C:3)
                -- BobINr44 _ownedByState:Bob {
                    (F:'';L:0;C:0)
                    state BEstablished final:0;initial:0;_superState:Bob;_ownedByRegion:BobINr44 {
                        (F:'';L:51;C:3) BEstablished --> BEstablished ACK[]/ (t51)
                        (F:'';L:52;C:3) BEstablished --> Bterminated BYE[]/ (t52)
                        (F:'';L:50;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a50)
                    } BEstablished
                    (F:'';L:0;C:0)
                    state BIdle final:0;initial:1;_superState:Bob;_ownedByRegion:BobINr44 {
                        (F:'';L:45;C:3) BIdle --> BInitiated INVITE[]/ (t45)
                    } BIdle
                    (F:'';L:0;C:0)
                    state BInitiated final:0;initial:0;_superState:Bob;_ownedByRegion:BobINr44 {
                        (F:'';L:48;C:3) BInitiated --> BEstablished Pickup[]/ (t48)
                        (F:'';L:47;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a47)
                        (F:'';L:57;C:3) BInitiated:precondition: (,state:Bob:currentState,!=,state:AIdle,), (a57)
                        (F:'';L:58;C:3) BInitiated:postcondition: (,state:Bob:currentState,!=,state:AInitiated,), (a58)
                        (F:'';L:59;C:3) BInitiated:invariant: (,state:Bob:currentState,!=,state:Aterminated,), (a59)
                    } BInitiated
                    (F:'';L:0;C:0)
                    state Bterminated final:1;initial:0;_superState:Bob;_ownedByRegion:BobINr44 {
                    } Bterminated
                } BobINr44
            } Bob
            (F:'';L:3;C:1)
            state ClosedSystemEnvironment final:0;initial:0;_superState:m1;_ownedByRegion:m1INr3 {
                (F:'';L:17;C:1) ClosedSystemEnvironment:ltl: ltlFinalStates,{,<>,[],(,state:ClosedSystemEnvironment:currentState,==,state:CallEnded,&&,state:Alice:currentState,==,state:Aterminated,&&,state:Bob:currentState,==,state:Bterminated,),}, (a17)
                (F:'';L:4;C:1)
                -- ClosedSystemEnvironmentINr4 _ownedByState:ClosedSystemEnvironment {
                    (F:'';L:0;C:0)
                    state AliceDial final:0;initial:1;_superState:ClosedSystemEnvironment;_ownedByRegion:ClosedSystemEnvironmentINr4 {
                        (F:'';L:6;C:1) AliceDial --> BobPickup NullEvent[state:Alice:currentState,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t6)
                        noInboundEvents,
                    } AliceDial
                    (F:'';L:0;C:0)
                    state AliceHangup final:0;initial:0;_superState:ClosedSystemEnvironment;_ownedByRegion:ClosedSystemEnvironmentINr4 {
                        (F:'';L:12;C:1) AliceHangup --> CallEnded NullEvent[state:Alice:currentState,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t12)
                        noInboundEvents,
                    } AliceHangup
                    (F:'';L:0;C:0)
                    state BobPickup final:0;initial:0;_superState:ClosedSystemEnvironment;_ownedByRegion:ClosedSystemEnvironmentINr4 {
                        (F:'';L:9;C:1) BobPickup --> AliceHangup NullEvent[state:Bob:currentState,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t9)
                        noInboundEvents,
                    } BobPickup
                    (F:'';L:0;C:0)
                    state CallEnded final:1;initial:0;_superState:ClosedSystemEnvironment;_ownedByRegion:ClosedSystemEnvironmentINr4 {
                        noInboundEvents,
                    } CallEnded
                } ClosedSystemEnvironmentINr4
            } ClosedSystemEnvironment
        } m1INr3
    } sip
    
*/


#define idx_unknown -1

#define idx_state_AEstablished 0
#define idx_state_AIdle 1
#define idx_state_AInitiated 2
#define idx_state_Alice 3
#define idx_state_AliceDial 4
#define idx_state_AliceHangup 5
#define idx_state_Aterminated 6
#define idx_state_BEstablished 7
#define idx_state_BIdle 8
#define idx_state_BInitiated 9
#define idx_state_Bob 10
#define idx_state_BobPickup 11
#define idx_state_Bterminated 12
#define idx_state_CallEnded 13
#define idx_state_ClosedSystemEnvironment 14

#define idx_region_AliceINr22 0
#define idx_region_BobINr44 1
#define idx_region_ClosedSystemEnvironmentINr4 2
#define idx_region_m1INr3 3

mtype = { event_1xx, event_2xx, event_ACK, event_BYE, event_Dial, event_EnterState, event_ExitState, event_Hangup, event_INVITE, event_NullEvent, event_Pickup, }

typedef event {mtype evId; short fromState; short toState};

chan _channels[4] = [4] of {event}; 


inline send_event(channel, evt, fs, ts)
{
    local event evtSend;
    evtSend.evId      = evt;
    evtSend.fromState = fs;
    evtSend.toState   = ts;
    _channels[channel]!evtSend;
}
    

proctype region_m1INr3() // sip
{
    local short myIdx = idx_region_m1INr3;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_unknown; 
    local short finalState = idx_unknown; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_Alice[*/

entry_Alice:    
    currentState = newState;
    noChannel = true;
    

body_Alice:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_m1INr3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Alice*/


/* state idx_state_Bob[*/

entry_Bob:    
    currentState = newState;
    noChannel = true;
    

body_Bob:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_m1INr3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Bob*/


/* state idx_state_ClosedSystemEnvironment[*/

entry_ClosedSystemEnvironment:    
    currentState = newState;
    noChannel = true;
    

body_ClosedSystemEnvironment:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_m1INr3 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_ClosedSystemEnvironment*/

} // region_m1INr3 sip


proctype region_AliceINr22() // Alice
{
    local short myIdx = idx_region_AliceINr22;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_AIdle; 
    local short finalState = idx_state_Aterminated; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_AIdle[*/

entry_AIdle:    
    currentState = newState;
    

body_AIdle:
loop_AIdle:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_AliceINr22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_AIdle[*/
    if
        
        //    (F:'';L:23;C:3) AIdle --> AInitiated Dial[]/ (t23)
        :: (evtRecv.evId == event_Dial) -> 
        newState = idx_state_AInitiated; 
        goto entry_AInitiated;
        
    fi
    /*]transitions idx_state_AIdle*/
    
/*]state idx_state_AIdle*/


/* state idx_state_AEstablished[*/

entry_AEstablished:    
    currentState = newState;
    
    //    (F:'';L:29;C:3) AEstablished:entry: send,event:ACK,to,state:Bob, (a29)
    send_event(idx_region_BobINr44, event_ACK, idx_state_AEstablished, idx_state_Bob); 
    

body_AEstablished:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_AliceINr22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_AEstablished[*/
    if
        
        //    (F:'';L:30;C:3) AEstablished --> Aterminated Hangup[]/ (t30)
        :: (evtRecv.evId == event_Hangup) -> 
        newState = idx_state_Aterminated; 
        goto entry_Aterminated;
        
    fi
    /*]transitions idx_state_AEstablished*/
    
/*]state idx_state_AEstablished*/


/* state idx_state_AInitiated[*/

entry_AInitiated:    
    currentState = newState;
    
    //    (F:'';L:36;C:3) AInitiated:precondition: (,state:Alice:currentState,!=,state:BIdle,), (a36)
    assert((region_AliceINr22:currentState !=idx_state_BIdle));
    
    //    (F:'';L:25;C:3) AInitiated:entry: send,event:INVITE,to,state:Bob, (a25)
    send_event(idx_region_BobINr44, event_INVITE, idx_state_AInitiated, idx_state_Bob); 
    

body_AInitiated:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_AliceINr22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_AInitiated[*/
    if
        
        //    (F:'';L:26;C:3) AInitiated --> AInitiated 1xx[]/ (t26)
        :: (evtRecv.evId == event_1xx) -> 
        //    (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)
        assert((region_AliceINr22:currentState !=idx_state_BInitiated));
        
        newState = idx_state_AInitiated; 
        goto body_AInitiated;
            
        //    (F:'';L:27;C:3) AInitiated --> AEstablished 2xx[]/ (t27)
        :: (evtRecv.evId == event_2xx) -> 
        //    (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)
        assert((region_AliceINr22:currentState !=idx_state_BInitiated));
        
        newState = idx_state_AEstablished; 
        goto entry_AEstablished;
        
    fi
    /*]transitions idx_state_AInitiated*/
    
    //    (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)
    assert((region_AliceINr22:currentState !=idx_state_BInitiated));
    
    //    (F:'';L:37;C:3) AInitiated:postcondition: (,state:Alice:currentState,!=,state:BInitiated,), (a37)
    assert((region_AliceINr22:currentState !=idx_state_BInitiated));
    
/*]state idx_state_AInitiated*/


/* state idx_state_Aterminated[*/

entry_Aterminated:    
    currentState = newState;
    noChannel = true;
    
    //    (F:'';L:32;C:3) Aterminated:entry: send,event:BYE,to,state:Bob, (a32)
    send_event(idx_region_BobINr44, event_BYE, idx_state_Aterminated, idx_state_Bob); 
    

body_Aterminated:
loop_Aterminated:    
    if
    :: ( noChannel == false ) -> end_Aterminated:
        myChan?evtRecv; 
        printf("MSC: > %d region_AliceINr22 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Aterminated*/

} // region_AliceINr22 Alice


proctype region_BobINr44() // Bob
{
    local short myIdx = idx_region_BobINr44;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_BIdle; 
    local short finalState = idx_state_Bterminated; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_BIdle[*/

entry_BIdle:    
    currentState = newState;
    

body_BIdle:
loop_BIdle:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_BobINr44 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_BIdle[*/
    if
        
        //    (F:'';L:45;C:3) BIdle --> BInitiated INVITE[]/ (t45)
        :: (evtRecv.evId == event_INVITE) -> 
        newState = idx_state_BInitiated; 
        goto entry_BInitiated;
        
    fi
    /*]transitions idx_state_BIdle*/
    
/*]state idx_state_BIdle*/


/* state idx_state_BEstablished[*/

entry_BEstablished:    
    currentState = newState;
    
    //    (F:'';L:50;C:3) BEstablished:entry: send,event:2xx,to,state:Alice, (a50)
    send_event(idx_region_AliceINr22, event_2xx, idx_state_BEstablished, idx_state_Alice); 
    

body_BEstablished:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_BobINr44 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_BEstablished[*/
    if
        
        //    (F:'';L:51;C:3) BEstablished --> BEstablished ACK[]/ (t51)
        :: (evtRecv.evId == event_ACK) -> 
        newState = idx_state_BEstablished; 
        goto body_BEstablished;
            
        //    (F:'';L:52;C:3) BEstablished --> Bterminated BYE[]/ (t52)
        :: (evtRecv.evId == event_BYE) -> 
        newState = idx_state_Bterminated; 
        goto entry_Bterminated;
        
    fi
    /*]transitions idx_state_BEstablished*/
    
/*]state idx_state_BEstablished*/


/* state idx_state_BInitiated[*/

entry_BInitiated:    
    currentState = newState;
    
    //    (F:'';L:57;C:3) BInitiated:precondition: (,state:Bob:currentState,!=,state:AIdle,), (a57)
    assert((region_BobINr44:currentState !=idx_state_AIdle));
    
    //    (F:'';L:47;C:3) BInitiated:entry: send,event:1xx,to,state:Alice, (a47)
    send_event(idx_region_AliceINr22, event_1xx, idx_state_BInitiated, idx_state_Alice); 
    

body_BInitiated:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_BobINr44 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_BInitiated[*/
    if
        
        //    (F:'';L:48;C:3) BInitiated --> BEstablished Pickup[]/ (t48)
        :: (evtRecv.evId == event_Pickup) -> 
        //    (F:'';L:58;C:3) BInitiated:postcondition: (,state:Bob:currentState,!=,state:AInitiated,), (a58)
        assert((region_BobINr44:currentState !=idx_state_AInitiated));
        
        newState = idx_state_BEstablished; 
        goto entry_BEstablished;
        
    fi
    /*]transitions idx_state_BInitiated*/
    
    //    (F:'';L:58;C:3) BInitiated:postcondition: (,state:Bob:currentState,!=,state:AInitiated,), (a58)
    assert((region_BobINr44:currentState !=idx_state_AInitiated));
    
    //    (F:'';L:58;C:3) BInitiated:postcondition: (,state:Bob:currentState,!=,state:AInitiated,), (a58)
    assert((region_BobINr44:currentState !=idx_state_AInitiated));
    
/*]state idx_state_BInitiated*/


/* state idx_state_Bterminated[*/

entry_Bterminated:    
    currentState = newState;
    noChannel = true;
    

body_Bterminated:
loop_Bterminated:    
    if
    :: ( noChannel == false ) -> end_Bterminated:
        myChan?evtRecv; 
        printf("MSC: > %d region_BobINr44 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_Bterminated*/

} // region_BobINr44 Bob


proctype region_ClosedSystemEnvironmentINr4() // ClosedSystemEnvironment
{
    local short myIdx = idx_region_ClosedSystemEnvironmentINr4;
    local chan myChan = _channels[myIdx]; xr myChan; 
    local event evtRecv; 
    local short initialState = idx_state_AliceDial; 
    local short finalState = idx_state_CallEnded; 
    local short currentState = initialState; 
    local short newState = initialState; 
    local bool noChannel = false; 
    

/* state idx_state_AliceDial[*/

entry_AliceDial:    
    currentState = newState;
    noChannel = true;
    

body_AliceDial:
loop_AliceDial:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_ClosedSystemEnvironmentINr4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_AliceDial[*/
    if
        
        //    (F:'';L:6;C:1) AliceDial --> BobPickup NullEvent[state:Alice:currentState,==,state:AIdle,]/send,event:Dial,to,state:Alice, (t6)
        :: (evtRecv.evId == event_NullEvent && region_AliceINr22:currentState ==idx_state_AIdle) -> 
        //    (F:'';L:0;C:0) idx_state_AliceDial:send: send,event:Dial,to,state:Alice, (a6)
        send_event(idx_region_AliceINr22, event_Dial, idx_state_AliceDial, idx_state_Alice); 
        
        newState = idx_state_BobPickup; 
        goto entry_BobPickup;
        
    fi
    /*]transitions idx_state_AliceDial*/
    
/*]state idx_state_AliceDial*/


/* state idx_state_AliceHangup[*/

entry_AliceHangup:    
    currentState = newState;
    noChannel = true;
    

body_AliceHangup:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_ClosedSystemEnvironmentINr4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_AliceHangup[*/
    if
        
        //    (F:'';L:12;C:1) AliceHangup --> CallEnded NullEvent[state:Alice:currentState,==,state:AEstablished,]/send,event:Hangup,to,state:Alice, (t12)
        :: (evtRecv.evId == event_NullEvent && region_AliceINr22:currentState ==idx_state_AEstablished) -> 
        //    (F:'';L:0;C:0) idx_state_AliceHangup:send: send,event:Hangup,to,state:Alice, (a12)
        send_event(idx_region_AliceINr22, event_Hangup, idx_state_AliceHangup, idx_state_Alice); 
        
        newState = idx_state_CallEnded; 
        goto entry_CallEnded;
        
    fi
    /*]transitions idx_state_AliceHangup*/
    
/*]state idx_state_AliceHangup*/


/* state idx_state_BobPickup[*/

entry_BobPickup:    
    currentState = newState;
    noChannel = true;
    

body_BobPickup:    
    if
    :: ( noChannel == false ) -> 
        myChan?evtRecv; 
        printf("MSC: > %d region_ClosedSystemEnvironmentINr4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
    /* transitions idx_state_BobPickup[*/
    if
        
        //    (F:'';L:9;C:1) BobPickup --> AliceHangup NullEvent[state:Bob:currentState,==,state:BInitiated,]/send,event:Pickup,to,state:Bob, (t9)
        :: (evtRecv.evId == event_NullEvent && region_BobINr44:currentState ==idx_state_BInitiated) -> 
        //    (F:'';L:0;C:0) idx_state_BobPickup:send: send,event:Pickup,to,state:Bob, (a9)
        send_event(idx_region_BobINr44, event_Pickup, idx_state_BobPickup, idx_state_Bob); 
        
        newState = idx_state_AliceHangup; 
        goto entry_AliceHangup;
        
    fi
    /*]transitions idx_state_BobPickup*/
    
/*]state idx_state_BobPickup*/


/* state idx_state_CallEnded[*/

entry_CallEnded:    
    currentState = newState;
    noChannel = true;
    

body_CallEnded:
loop_CallEnded:    
    if
    :: ( noChannel == false ) -> end_CallEnded:
        myChan?evtRecv; 
        printf("MSC: > %d region_ClosedSystemEnvironmentINr4 event %e in state %d\n", myIdx, evtRecv.evId, currentState); 
    :: else
        evtRecv.evId = event_NullEvent;
    fi
    
    
/*]state idx_state_CallEnded*/

} // region_ClosedSystemEnvironmentINr4 ClosedSystemEnvironment


proctype invariants() {
end_invariants:
progress_invariants:    
    do
    :: ! (1 != 2) -> assert(false); // ensure at least one statement
    
    //    (F:'';L:38;C:3) AInitiated:invariant: (,state:Alice:currentState,!=,state:Bterminated,), (a38)
    :: atomic { !((region_AliceINr22:currentState !=idx_state_Bterminated)) -> assert((region_AliceINr22:currentState !=idx_state_Bterminated)) };
    
    //    (F:'';L:59;C:3) BInitiated:invariant: (,state:Bob:currentState,!=,state:Aterminated,), (a59)
    :: atomic { !((region_BobINr44:currentState !=idx_state_Aterminated)) -> assert((region_BobINr44:currentState !=idx_state_Aterminated)) };
    
    od
} // invariants


init {
    atomic {
        run region_AliceINr22(); 
        run region_BobINr44(); 
        run region_ClosedSystemEnvironmentINr4(); 
        run region_m1INr3(); 
        run invariants(); 
    }
    //(_nr_pr == 1); 
} // init


// ltl claims: run with spin -ltl xyz or spin -noclaim 
//    (F:'';L:17;C:1) ClosedSystemEnvironment:ltl: ltlFinalStates,{,<>,[],(,state:ClosedSystemEnvironment:currentState,==,state:CallEnded,&&,state:Alice:currentState,==,state:Aterminated,&&,state:Bob:currentState,==,state:Bterminated,),}, (a17)
ltl ltlFinalStates { <> [] ( region_ClosedSystemEnvironmentINr4:currentState  == idx_state_CallEnded && region_AliceINr22:currentState  == idx_state_Aterminated && region_BobINr44:currentState  == idx_state_Bterminated ) } ;
 





/*UPML end*/

